{"version":3,"sources":["webpack:///2.TerriaMap.js","webpack:///./node_modules/terriajs/lib/ReactViews/Map/Navigation/augmented_virtuality_tool.scss?5228","webpack:///./node_modules/terriajs/lib/Models/AugmentedVirtuality.js","webpack:///./node_modules/terriajs/lib/ReactViews/Map/Navigation/AugmentedVirtualityTool.jsx"],"names":["webpackJsonp","2276","module","exports","btn","btn-primary","btnPrimary","btn-blink","btnBlink","btn-primary--hover","btnPrimaryHover","blinker","toolButton","augmentedVirtualityTool","2277","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_defined","_defined2","_defaultValue","_defaultValue2","_knockout","_knockout2","_Math","_Math2","_Matrix","_Matrix2","_Cartesian","_Cartesian2","_EllipsoidTerrainProvider","_EllipsoidTerrainProvider2","_sampleTerrainMostDetailed","_sampleTerrainMostDetailed2","AugmentedVirtuality","terria","that","this","_terria","_eventLoopState","_manualAlignment","_maximumUpdatesPerSecond","DEFAULT_MAXIMUM_UPDATES_PER_SECOND","_orientationUpdated","_alpha","_beta","_gamma","_realignAlpha","_realignHeading","_hoverLevel","PRESET_HEIGHTS","length","window","addEventListener","event","_storeOrientation","track","defineProperty","get","_eventLoopRunning","set","enable","resetAlignment","enabled","_startEventLoop","_getManualAlignment","startEnd","_setManualAlignment","maximumUpdatesPerSecond","MINIMUM_HOVER_HEIGHT","prototype","toggleEnabled","toggleManualAlignment","manualAlignment","toggleHoverHeight","hover","height","position","flyTo","flyToHeight","surfaceHeight","newPosition","fromRadians","longitude","latitude","pose","_getCurrentOrientation","destination","camera","setView","currentViewer","notifyRepaintRequired","cesium","viewer","positionCartographic","clone","scene","terrainProvider","then","updatedPosition","moveTo","maximumHeight","moveToLocation","hoverHeight","viewerHeight","cameraPosition","undefined","toDegrees","heading","intervalId","intervalMs","id","setInterval","_updateOrientation","clearInterval","alpha","beta","gamma","screenOrientation","_getCurrentScreenOrientation","_lastScreenOrientation","realignAlpha","realignHeading","_computeTerriaOrientation","rotation","IDENTITY","rotationIncrement","fromRotationZ","toRadians","multiply","fromRotationX","fromRotationY","r10","COLUMN1ROW0","r11","COLUMN1ROW1","r02","COLUMN0ROW2","r12","COLUMN1ROW2","r22","COLUMN2ROW2","Math","atan2","roll","pitch","sqrt","orientation","screen","angle","806","_react","_react2","_createReactClass","_createReactClass2","_propTypes","_propTypes2","_ObserveModelMixin","_ObserveModelMixin2","_augmented_virtuality_tool","_augmented_virtuality_tool2","_Icon","_Icon2","_ViewerMode","_ViewerMode2","_AugmentedVirtuality","_AugmentedVirtuality2","AugmentedVirtualityTool","displayName","mixins","propTypes","object","isRequired","viewState","experimentalWarning","bool","getInitialState","augmentedVirtuality","props","experimentalWarningShown","realignHelpShown","resetRealignHelpShown","handleClickAVTool","state","setState","notifications","push","title","message","confirmText","handleClickRealign","handleClickResetRealign","handleClickHover","render","toggleImage","GLYPHS","arOff","toggleStyle","arOn","realignment","realignmentStyle","hoverLevel","hoverImage","arHover0","arHover1","arHover2","viewerMode","Leaflet","createElement","className","type","onClick","glyph","key","manualAlignmentSet","arRealign","arResetAlignment"],"mappings":"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","file":"2.TerriaMap.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 2276:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\nmodule.exports = {\"btn\":\"tjs-augmented_virtuality_tool__btn tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnPrimary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-blink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnBlink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary--hover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"btnPrimaryHover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"blinker\":\"tjs-augmented_virtuality_tool__blinker\",\"toolButton\":\"tjs-augmented_virtuality_tool__toolButton\",\"augmentedVirtualityTool\":\"tjs-augmented_virtuality_tool__augmentedVirtualityTool tjs-tool_button__toolButton\"};\n\n/***/ }),\n\n/***/ 2277:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _defined = __webpack_require__(0);\n\nvar _defined2 = _interopRequireDefault(_defined);\n\nvar _defaultValue = __webpack_require__(1);\n\nvar _defaultValue2 = _interopRequireDefault(_defaultValue);\n\nvar _knockout = __webpack_require__(13);\n\nvar _knockout2 = _interopRequireDefault(_knockout);\n\nvar _Math = __webpack_require__(9);\n\nvar _Math2 = _interopRequireDefault(_Math);\n\nvar _Matrix = __webpack_require__(40);\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nvar _Cartesian = __webpack_require__(10);\n\nvar _Cartesian2 = _interopRequireDefault(_Cartesian);\n\nvar _EllipsoidTerrainProvider = __webpack_require__(436);\n\nvar _EllipsoidTerrainProvider2 = _interopRequireDefault(_EllipsoidTerrainProvider);\n\nvar _sampleTerrainMostDetailed = __webpack_require__(799);\n\nvar _sampleTerrainMostDetailed2 = _interopRequireDefault(_sampleTerrainMostDetailed);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * Manages state for Augmented Virtuality mode.\r\n *\r\n * This mode uses the devices orientation sensors to change the viewers viewport to match the change in orientation.\r\n *\r\n * Term Augmented Virtuality:\r\n * \"The use of real-world sensor information (e.g., gyroscopes) to control a virtual environment is an additional form\r\n * of augmented virtuality, in which external inputs provide context for the virtual view.\"\r\n * {@link https://en.wikipedia.org/wiki/Mixed_reality}\r\n *\r\n * @alias AugmentedVirtuality\r\n * @constructor\r\n */\nvar AugmentedVirtuality = function AugmentedVirtuality(terria) {\n    var that = this;\n\n    this._terria = terria;\n\n    // Note: We create a persistant object and define a transient property, since knockout needs a persistant variable\n    //       to track, but for state we want a 'maybe' intervalId.\n    this._eventLoopState = {};\n\n    this._manualAlignment = false;\n\n    this._maximumUpdatesPerSecond = AugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND;\n\n    this._orientationUpdated = false;\n    this._alpha = 0;\n    this._beta = 0;\n    this._gamma = 0;\n    this._realignAlpha = 0;\n    this._realignHeading = 0;\n\n    // Set the default height to be the last height so that when we first toggle (and increment) we cycle and go to the first height.\n    this._hoverLevel = AugmentedVirtuality.PRESET_HEIGHTS.length - 1;\n\n    // Always run the device orientation event, this way as soon as we enable we know where we are and set the\n    // orientation rather then having to wait for the next update.\n    // The following is disabled because chrome does not currently support deviceorientationabsolute correctly:\n    // if ('ondeviceorientationabsolute' in window)\n    // {\n    //     window.addEventListener('deviceorientationabsolute', function(event) {that._orientationUpdate(event);} );\n    // }\n    // else\n    if ('ondeviceorientation' in window) {\n        window.addEventListener('deviceorientation', function (event) {\n            that._storeOrientation(event);\n        });\n    }\n\n    // Make the variables used by the object properties knockout observable so that changes in the state notify the UI\n    // and cause a UI update. Note: These are all of the variables used just by the getters (not the setters), since\n    // these unqiquely define what the current state is and are the only things that can effect/cause the state to change\n    // (note: _eventLoopState is hidden behind ._eventLoopRunning() ).\n    _knockout2.default.track(this, ['_eventLoopState', '_manualAlignment', '_maximumUpdatesPerSecond', '_realignAlpha', '_realignHeading', '_hoverLevel']);\n\n    // Note: The following properties are defined as knockout properties so that they can be used to trigger updates on the UI.\n    /**\r\n     * Gets or sets whether Augmented Virtuality mode is currently enabled (true) or not (false).\r\n     *\r\n     * Note: If {@link AugmentedVirtuality#manualAlignment} is enabled and the state is changed it will be disabled.\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {Boolean} enabled\r\n     */\n    _knockout2.default.defineProperty(this, 'enabled', {\n        get: function get() {\n            return this._eventLoopRunning() || this._manualAlignment;\n        },\n        set: function set(enable) {\n            if (enable !== true) {\n                enable = false;\n\n                this.resetAlignment();\n            }\n\n            if (enable !== this.enabled) {\n                // If we are changing the enabled state then disable manual alignment.\n                // We only do this if we are changing the enabled state so that the client can repeatedly call the\n                // setting without having any effect if they aren't changing the enabled state, but so that every time\n                // that the state is changed that the manual alignment is turned back off initally.\n                this._manualAlignment = false;\n\n                this._startEventLoop(enable);\n            }\n        }\n    });\n\n    /**\r\n     * Gets or sets whether manual realignment mode is currently enabled (true) or not (false).\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {Boolean} manualAlignment\r\n     */\n    _knockout2.default.defineProperty(this, 'manualAlignment', {\n        get: function get() {\n            return this._getManualAlignment();\n        },\n        set: function set(startEnd) {\n            this._setManualAlignment(startEnd);\n        }\n    });\n\n    /**\r\n     * Gets whether a manual realignment has been specified (true) or not (false).\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {Boolean} manualAlignmentSet\r\n     */\n    _knockout2.default.defineProperty(this, 'manualAlignmentSet', {\n        get: function get() {\n            return this._realignAlpha !== 0.0 || this._realignHeading !== 0.0;\n        }\n    });\n\n    /**\r\n     * Gets the index of the current hover level.\r\n     *\r\n     * Use <code>AugmentedVirtuality.PRESET_HEIGHTS.length</code> to find the total avaliable levels.\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {int} hoverLevel\r\n     */\n    _knockout2.default.defineProperty(this, 'hoverLevel', {\n        get: function get() {\n            return this._hoverLevel;\n        }\n    });\n\n    /**\r\n     * Gets or sets the the maximum number of times that the camera orientation will be updated per second. This is\r\n     * the number of camera orientation updates per seconds is capped to (explicitly the number of times the\r\n     * orientation is updated per second might be less but it won't be more then this number). We want the number of\r\n     * times that the orientation is updated capped so that we don't consume to much battery life updating to\r\n     * frequently, but responsiveness is still acceptable.\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {Float} maximumUpdatesPerSecond\r\n     */\n    _knockout2.default.defineProperty(this, 'maximumUpdatesPerSecond', {\n        get: function get() {\n            return this._maximumUpdatesPerSecond;\n        },\n        set: function set(maximumUpdatesPerSecond) {\n            this._maximumUpdatesPerSecond = maximumUpdatesPerSecond;\n\n            // If we are currently enabled reset to update the timing interval used.\n            if (this._eventLoopRunning()) {\n                this._startEventLoop(false);\n                this._startEventLoop(true);\n            }\n        }\n    });\n\n    this.enabled = false;\n};\n\n/**\r\n * Gets the the maximum number of times that the camera orientation will be updated per second by default. This is the\r\n * number of camera orientation updates per seconds is capped to by default (explicitly the number of times the\r\n * orientation is updated per second might be less but it won't be more then this number). We want the number of times\r\n * that the orientation is updated capped so that we don't consume to much battery life updating to frequently, but\r\n * responsiveness is still acceptable.\r\n */\nAugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND = 10.0;\n\n/**\r\n * The minimum height that the viewer is allowed to hover at.\r\n */\nAugmentedVirtuality.MINIMUM_HOVER_HEIGHT = 20.0;\n\n/* These are the heights that we can toggle through (in meters - above the surface height).\r\n */\nAugmentedVirtuality.PRESET_HEIGHTS = [1000, 250, 20];\n\n/**\r\n * Toggles whether the AugmentedVirutuality mode is enabled or disabled.\r\n */\nAugmentedVirtuality.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled;\n};\n\n/**\r\n * Toggles whether manual alignement is enabled or disabled.\r\n */\nAugmentedVirtuality.prototype.toggleManualAlignment = function () {\n    this.manualAlignment = !this.manualAlignment;\n};\n\n/**\r\n * Resets the alignment so that the alignement matches the devices absolute alignment.\r\n */\nAugmentedVirtuality.prototype.resetAlignment = function () {\n    this._orientationUpdated = true;\n    this._realignAlpha = 0;\n    this._realignHeading = 0;\n};\n\n/**\r\n * Toggles the viewer between a range of predefined heights, setting the cameras orientation so that it matches the\r\n * correct orientation.\r\n */\nAugmentedVirtuality.prototype.toggleHoverHeight = function () {\n    this._hoverLevel = (this._hoverLevel + 1) % AugmentedVirtuality.PRESET_HEIGHTS.length;\n\n    this.hover(AugmentedVirtuality.PRESET_HEIGHTS[this._hoverLevel]);\n};\n\n/**\r\n * Moves the viewer to a specified height, setting the orientation so that it matches the correct Augmented Virtuality\r\n * orientation.\r\n *\r\n * @param {Float} height The height in Meters above the globe surface. Note: If height is below\r\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} the height will be set to\r\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} to avoid visual artifacts when the viewer\r\n *                       becomes to close to the surface.\r\n * @param {Cartographic} [position] The location to hover over. If not specified the current camera location will be used.\r\n * @param {Boolean} [flyTo=true] Whether to fly to the location (true) or whether to jump to the location (false).\r\n */\nAugmentedVirtuality.prototype.hover = function (height, position, flyTo) {\n    var that = this;\n\n    // Get access to the camera...if it is not avaliable we can't set the new height so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    if (!(0, _defined2.default)(position)) {\n        position = camera.positionCartographic.clone();\n    }\n\n    flyTo = (0, _defaultValue2.default)(flyTo, true);\n\n    // Clamp the minimum hover height (heights below this value could lead to poor visual artifacts).\n    if (height < AugmentedVirtuality.MINIMUM_HOVER_HEIGHT) {\n        height = AugmentedVirtuality.MINIMUM_HOVER_HEIGHT;\n    }\n\n    // Reset the viewer height.\n    function flyToHeight(surfaceHeight) {\n        if ((0, _defined2.default)(surfaceHeight)) {\n            height += surfaceHeight;\n        }\n\n        var newPosition = _Cartesian2.default.fromRadians(position.longitude, position.latitude, height);\n        var pose = that._getCurrentOrientation();\n        pose.destination = newPosition;\n\n        if (flyTo) {\n            camera.flyTo(pose);\n        } else {\n            camera.setView(pose);\n        }\n\n        // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n        // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n        // the view orientation does not visually update until the user manualy moves the camera position).\n        that._terria.currentViewer.notifyRepaintRequired();\n    }\n\n    // Get the ground surface height at this location and offset the height by it.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.scene) || !(0, _defined2.default)(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider2.default) {\n        // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n        flyToHeight(0);\n    } else {\n        var terrainProvider = this._terria.cesium.scene.terrainProvider;\n        (0, _sampleTerrainMostDetailed2.default)(terrainProvider, [position]).then(function (updatedPosition) {\n            flyToHeight(updatedPosition[0].height);\n        });\n    }\n};\n\n/**\r\n * Moves the viewer to a specified location while maintaining the current height and the correct Augmented Virtuality\r\n * orientation.\r\n *\r\n * @param {Cartographic} position The location to hover move to.\r\n * @param {Float} [maximumHeight] The maximum height (in meters) to cap the current camera height to (if this value is\r\n *                                specified and the viewer is above this height the camera will be restricted to this height).\r\n * @param {Boolean} [flyTo] Whether to fly to the location (true) or whether to jump to the location (false).\r\n *\r\n * When the manual alignment is enabled this function has no effect.\r\n */\nAugmentedVirtuality.prototype.moveTo = function (position, maximumHeight, flyTo) {\n    var that = this;\n\n    // If we are in manual alignment mode we don't allow the viewer to move (since this would create a jaring UX for most use cases).\n    if (this._manualAlignment) {\n        return;\n    }\n\n    // Get access to the camera...if it is not avaliable we can't get the current height (or set the new location) so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    var cameraPosition = camera.positionCartographic.clone();\n    var viewerHeight = cameraPosition.height;\n\n    // Reset the viewer height.\n    function moveToLocation(surfaceHeight) {\n        if (!(0, _defined2.default)(surfaceHeight)) {\n            surfaceHeight = 0;\n        }\n\n        var hoverHeight = viewerHeight - surfaceHeight;\n        if ((0, _defined2.default)(maximumHeight) && hoverHeight > maximumHeight) {\n\n            hoverHeight = maximumHeight;\n        }\n\n        that.hover(hoverHeight, position, flyTo);\n    }\n\n    // Get the ground surface height at this location and offset the height by it.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.scene) || !(0, _defined2.default)(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider2.default) {\n        // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n        moveToLocation(undefined);\n    } else {\n        var terrainProvider = this._terria.cesium.scene.terrainProvider;\n        (0, _sampleTerrainMostDetailed2.default)(terrainProvider, [cameraPosition]).then(function (updatedPosition) {\n            moveToLocation(updatedPosition[0].height);\n        });\n    }\n};\n\n/**\r\n * Whether the user is currently setting a manual alignment.\r\n *\r\n * See also {@link AugmentedVirtuality#_setManualAlignment}.\r\n *\r\n * @return {Boolean} Whether the user is currently setting a manual alignment (true) or not (false).\r\n * @private\r\n */\nAugmentedVirtuality.prototype._getManualAlignment = function () {\n    return this.enabled && this._manualAlignment;\n};\n\n/**\r\n * Starts / stops manual alignment.\r\n *\r\n * When manual realignment is enabled it allows the user to specify a new origin for the alignment between the devices\r\n * physical and virtual alignment. When manual alignment is enabled the orientation is locked, to allow the user to\r\n * realign a visual landmark with a physical landmark.\r\n *\r\n * Note: Manual alignment is only done for the heading axis, this is because in practice we have found that the heading\r\n * axis is often out as mobile devices seem to have difficulty obtaining the compass direction, but seem to perform\r\n * relatively well in the other axes.\r\n *\r\n * Note: Realignment is only possible when AugmentedVirtuality is enabled. If AugmentedVirtuality is disabled while\r\n *       manual alignment is in progress it will be cancelled.\r\n *\r\n * See also {@link AugmentedVirtuality#_getManualAlignment}.\r\n *\r\n * @param {Boolean} startEnd Whether the user is starting (true) or ending (false) the realignment.\r\n * @private\r\n */\nAugmentedVirtuality.prototype._setManualAlignment = function (startEnd) {\n    // Only allow manual alignment changes when the module is enabled.\n    if (this.enabled !== true) {\n        return;\n    }\n\n    // Sanitise the input value to a boolean.\n    if (startEnd !== true) {\n        startEnd = false;\n    }\n\n    if (startEnd === false && (0, _defined2.default)(this._terria.cesium) && (0, _defined2.default)(this._terria.cesium.viewer) && (0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        this._realignAlpha = this._alpha;\n        this._realignHeading = _Math2.default.toDegrees(this._terria.cesium.viewer.camera.heading);\n    }\n\n    if (this._manualAlignment !== startEnd) {\n        this._manualAlignment = startEnd;\n        this._startEventLoop(!this._manualAlignment);\n    }\n};\n\n/**\r\n * Whether the event loop is currently running.\r\n *\r\n * @return {Boolean} enable Whether to start the event loop is currently running (true) or not (false).\r\n * @private\r\n */\nAugmentedVirtuality.prototype._eventLoopRunning = function () {\n    return (0, _defined2.default)(this._eventLoopState.intervalId);\n};\n\n/**\r\n * Start or stop the Augmented Virutuality mode event loop. When enabled the orientation will effect the cameras\r\n * view and when disabled the device orientation will not effect the cameras view.\r\n *\r\n * @param {Boolean} enable Whether to start the event loop (true) or stop the event loop (false).\r\n * @private\r\n */\nAugmentedVirtuality.prototype._startEventLoop = function (enable) {\n    // Are we actually changing the state?\n    if (this._eventLoopRunning() !== enable) {\n        if (enable === true) {\n            var that = this;\n\n            this._orientationUpdated = true;\n\n            var intervalMs = 1000 / this._maximumUpdatesPerSecond;\n            var id = setInterval(function () {\n                that._updateOrientation();\n            }, intervalMs);\n            this._eventLoopState = { intervalId: id };\n        } else {\n            clearInterval(this._eventLoopState.intervalId);\n            this._eventLoopState = {};\n        }\n    }\n};\n\n/**\r\n * Device orientation update event callback function. Stores the updated orientation into the object state.\r\n *\r\n * @param {Object} event Contains the updated device orientation (in .alpha, .beta, .gamma).\r\n * @private\r\n */\nAugmentedVirtuality.prototype._storeOrientation = function (event) {\n    this._alpha = event.alpha;\n    this._beta = event.beta;\n    this._gamma = event.gamma;\n    this._orientationUpdated = true;\n};\n\n/**\r\n * This function updates the cameras orientation using the last orientation recorded and the current screen orientation.\r\n *\r\n * @private\r\n */\nAugmentedVirtuality.prototype._updateOrientation = function () {\n\n    // Check if the screen orientation has changed and mark the orientation updated if it has.\n    var screenOrientation = this._getCurrentScreenOrientation();\n    if (screenOrientation !== this._lastScreenOrientation) {\n        this._orientationUpdated = true;\n    }\n    this._lastScreenOrientation = screenOrientation;\n\n    // Optomise by only updating the camera view if some part of the orientation calculation has changed.\n    if (!this._orientationUpdated) {\n        // The orientation has not been updated so don't waste time changing the orientation.\n        return;\n    }\n    this._orientationUpdated = false;\n\n    // Get access to the camera...if it is not avaliable we can't set the orientation so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    camera.setView(this._getCurrentOrientation(screenOrientation));\n\n    // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n    // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n    // the view orientation does not visually update until the user manualy moves the camera position).\n    this._terria.currentViewer.notifyRepaintRequired();\n};\n\n/**\r\n * Gets the current orientation stored in the object state and returns the roll, pitch and heading which can be used to set the cameras orientation.\r\n *\r\n * @param {Float} screenOrientation The screen orientation in degrees. Note: This field is optional, if supplied this value will be used for the screen orientation, otherwise the screen orientation will be obtained during the execution of this function.\r\n * @return {Object} A object with the roll, pitch and heading stored into the orientation.\r\n * @private\r\n */\nAugmentedVirtuality.prototype._getCurrentOrientation = function (screenOrientation) {\n    var alpha = this._alpha;\n    var beta = this._beta;\n    var gamma = this._gamma;\n\n    var realignAlpha = this._realignAlpha;\n    var realignHeading = this._realignHeading;\n\n    if (!(0, _defined2.default)(screenOrientation)) {\n        screenOrientation = this._getCurrentScreenOrientation();\n    }\n\n    return this._computeTerriaOrientation(alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading);\n};\n\n/**\r\n * Turns the orientation in the device frame of reference into an orientation suitable for specifying the Terria camera orientation.\r\n *\r\n * @param {Float} alpha The alpha value of the device orientation in degrees (this is the alpha value in the device's frame of reference).\r\n * @param {Float} beta  The beta  value of the device orientation in degrees (this is the beta  value in the device's frame of reference).\r\n * @param {Float} gamma The gamma value of the device orientation in degrees (this is the gamma value in the device's frame of reference).\r\n * @param {Float} screenOrientation The screen orientation in degrees.\r\n * @param {Float} realignAlpha   The value of the alpha   value the last time realignment was completed (supply zero if realignment is not supported).\r\n * @param {Float} realignHeading The value of the heading value the last time realignment was completed (supply zero if realignment is not supported).\r\n * @return {Object} An object with the roll, pitch and heading stored into the orientation.\r\n * @private\r\n */\nAugmentedVirtuality.prototype._computeTerriaOrientation = function (alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading) {\n    // Note: The algorithmic formulation in this function is for simplicity of mathematical expression, readability,\n    //       maintainability and modification (i.e. it is easy to understand how to update or insert new offsets or features).\n    //       This is not the simplest form which clearly flows from the current formuleation and clearly simplify the\n    //       logic and operations but would increase the cost of future modifications and reduce the readability of the\n    //       expression. It is not anticipated that the current verbose implementation would have a significant impact\n    //       on performance or accuracy, but obviously there will be some impact on both and it can be simplified in\n    //       future if needed.\n\n    var rotation = _Matrix2.default.clone(_Matrix2.default.IDENTITY, rotation);\n    var rotationIncrement = void 0;\n\n    // Roll - Counteract the change in the (orientation) frame of reference when the screen is rotated and the\n    //        rotation lock is not on (the browser reorients the frame of reference to align with the new screen\n    //        orientation - where as we want it of the device relative to the world).\n    rotationIncrement = _Matrix2.default.fromRotationZ(_Math2.default.toRadians(screenOrientation));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Pitch - Align the device orientation frame with the ceasium orientation frame.\n    rotationIncrement = _Matrix2.default.fromRotationX(_Math2.default.toRadians(90));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Roll - Apply the deivce roll.\n    rotationIncrement = _Matrix2.default.fromRotationZ(_Math2.default.toRadians(gamma));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Pitch - Apply the deivce pitch.\n    rotationIncrement = _Matrix2.default.fromRotationX(_Math2.default.toRadians(-beta));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Heading - Apply the incremental deivce heading (from when start was last triggered).\n    rotationIncrement = _Matrix2.default.fromRotationY(_Math2.default.toRadians(-(alpha - realignAlpha)));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Heading - Use the offset when the orientation was last started.\n    //           Note: This is logically different from the alpha value and can only be applied here in the same way\n    //                 since Cesium camera is RPH (Heading last - most local). See Cesium camera rotation decomposition\n    //                 for more information on the Cesium camera formuleation.\n    rotationIncrement = _Matrix2.default.fromRotationY(_Math2.default.toRadians(realignHeading));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Decompose rotation matrix into roll, pitch and heading to supply to Cesium camera.\n    //\n    // Use notation:\n    //     R = Roll, P = Pitch, H = Heading\n    //     SH = Sin(Heading), CH = Cos(Heading)\n    //\n    // Ceasium camera rotation = RPH:\n    //     [ CR, -SR,   0][  1,   0,   0][ CH,   0,  SH]   [CRCH-SRSPSH, -SRCP, CRSH-SRSPCH]\n    //     [ SR,  CR,   0][  0,  CP,  SP][  0,   1,   0] = [SRCH-CRSPSH,  CRCP, SRSH+CRSPCH]\n    //     [  0,   0,   1][  0, -SP,  CP][-SH,   0,  CH]   [   -CPSH   ,   -SP,    CPCH    ]\n    //     Note: The sign difference of the Sin terms in pitch is different to the standard right handed rotation since\n    //           Cesium rotates pitch in the left handed direction. Both heading and roll are right handed rotations.\n    //\n    // Use the following notation to refer to elements in the Cesium camera rotation matrix:\n    //     [R00, R10, R20]\n    //     [R01, R11, R21]\n    //     [R02, R12, R22]\n    //\n    // Also note: Tan(X) = Sin(X) / Cos(X)\n    //\n    // Decompose matrix:\n    //    H = ATan(Tan(H)) = ATan(Sin(H)/Cos(H)) = ATan (SH / CH) = ATan(CPSH/CPCH) = ATan (-R02 / R22)\n    //    R = ATan(Tan(R)) = ATan(Sin(R)/Cos(R)) = ATan (SR / CR) = ATan(SRCP/CRCP) = ATan (-R10 / R11)\n    //    P = ATan(Tan(P)) = ATan(Sin(P)/Cos(P)) = ATan (SP / CP)\n    //                                             SP = -R12\n    //                                             Need to find CP:\n    //                                                 CP = Sqrt(CP^2)\n    //                                                    = Sqrt(CP^2*(CH^2+SH^2))              Since: (Cos@^2 + Sin@^2) = 1\n    //                                                    = Sqrt((CP^2)*(CH^2) + (CP^2)*(SH^2)) Expand\n    //                                                    = Sqrt((CPCH)^2 + (CPSH)^2)           Since: N^2*M^2 = (NM)^2\n    //                                                    = Sqrt(R22^2 + (-R02)^2)              Substitute\n    //                                                    = Sqrt(R22^2 + R02^2)                 Since: (-N)^2 = N^2\n    //  So P = ATan (-R12 / Sqrt(R22^2 + R02^2))\n\n\n    // Simplify notation for readability:\n    var r10 = rotation[_Matrix2.default.COLUMN1ROW0];\n    var r11 = rotation[_Matrix2.default.COLUMN1ROW1];\n    var r02 = rotation[_Matrix2.default.COLUMN0ROW2];\n    var r12 = rotation[_Matrix2.default.COLUMN1ROW2];\n    var r22 = rotation[_Matrix2.default.COLUMN2ROW2];\n\n    var heading = _Math2.default.toDegrees(Math.atan2(-r02, r22));\n    var roll = _Math2.default.toDegrees(Math.atan2(-r10, r11));\n    var pitch = _Math2.default.toDegrees(Math.atan2(-r12, Math.sqrt(r02 * r02 + r22 * r22)));\n\n    // Create an object with the roll, pitch and heading we just computed.\n    return {\n        orientation: {\n            roll: _Math2.default.toRadians(roll),\n            pitch: _Math2.default.toRadians(pitch),\n            heading: _Math2.default.toRadians(heading)\n        }\n    };\n};\n\n/**\r\n * Gets the current screen orientation.\r\n *\r\n * @return {Object} The current screen orientation in degrees.\r\n * @private\r\n */\nAugmentedVirtuality.prototype._getCurrentScreenOrientation = function () {\n    if ((0, _defined2.default)(screen.orientation) && (0, _defined2.default)(screen.orientation.angle)) {\n        return screen.orientation.angle;\n    }\n\n    if ((0, _defined2.default)(window.orientation)) {\n        return window.orientation;\n    }\n\n    return 0;\n};\n\nmodule.exports = AugmentedVirtuality;\n\n/***/ }),\n\n/***/ 806:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _react = __webpack_require__(4);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _createReactClass = __webpack_require__(8);\n\nvar _createReactClass2 = _interopRequireDefault(_createReactClass);\n\nvar _propTypes = __webpack_require__(5);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _ObserveModelMixin = __webpack_require__(11);\n\nvar _ObserveModelMixin2 = _interopRequireDefault(_ObserveModelMixin);\n\nvar _augmented_virtuality_tool = __webpack_require__(2276);\n\nvar _augmented_virtuality_tool2 = _interopRequireDefault(_augmented_virtuality_tool);\n\nvar _Icon = __webpack_require__(30);\n\nvar _Icon2 = _interopRequireDefault(_Icon);\n\nvar _ViewerMode = __webpack_require__(134);\n\nvar _ViewerMode2 = _interopRequireDefault(_ViewerMode);\n\nvar _defined = __webpack_require__(0);\n\nvar _defined2 = _interopRequireDefault(_defined);\n\nvar _AugmentedVirtuality = __webpack_require__(2277);\n\nvar _AugmentedVirtuality2 = _interopRequireDefault(_AugmentedVirtuality);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar AugmentedVirtualityTool = (0, _createReactClass2.default)({\n    displayName: 'AugmentedVirtualityTool',\n    mixins: [_ObserveModelMixin2.default],\n\n    propTypes: {\n        terria: _propTypes2.default.object.isRequired,\n        viewState: _propTypes2.default.object.isRequired,\n        experimentalWarning: _propTypes2.default.bool\n    },\n\n    getInitialState: function getInitialState() {\n        return {\n            augmentedVirtuality: new _AugmentedVirtuality2.default(this.props.terria),\n            experimentalWarningShown: false,\n            realignHelpShown: false,\n            resetRealignHelpShown: false\n        };\n    },\n    handleClickAVTool: function handleClickAVTool() {\n        // Make the AugmentedVirtuality module avaliable elsewhere.\n        this.props.terria.augmentedVirtuality = this.state.augmentedVirtuality;\n\n        if ((0, _defined2.default)(this.props.experimentalWarning) && this.props.experimentalWarning !== false && !this.state.experimentalWarningShown) {\n\n            this.setState({ experimentalWarningShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Experimental Feature: Augmented Reality',\n                message: 'Augmented Reality mode is currently in beta. ' + 'This mode is only designed for use on the latest high end mobile devices. ' + '<br /><br />WARNING: This mode can consume a lot of data, please be mindful of data usage charges from your network provider. ' + '<br /><br />The accuracy of this mode depends on the accuracy of your mobile devices internal compass.',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.toggleEnabled();\n    },\n    handleClickRealign: function handleClickRealign() {\n        if (!this.state.realignHelpShown) {\n            this.setState({ realignHelpShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Manual Alignment',\n                message: 'Align your mobile device so that it corresponds with the maps current alignment, then click the blinking compass.' + ' If no landmarks to align with are currently visible on the map, you can move the map using' + ' drag and pinch actions until a recognisable landmark is visible before aligning the device with the map.' + '<br /><div><img width=\"100%\" src=\"./build/TerriaJS/images/ar-realign-guide.gif\" /></div>' + '<br />Tip: The sun or moon are often good landmarks to align with if you are in a location you aren\\x27t familiar with (be careful not to look at the sun - it can hurt your eyes).',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.toggleManualAlignment();\n    },\n    handleClickResetRealign: function handleClickResetRealign() {\n        if (!this.state.resetRealignHelpShown) {\n            this.setState({ resetRealignHelpShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Reset Alignment',\n                message: 'Resetting to compass alignment. If the alignment doesn\\x27t match the real world try waving' + ' your device in a figure 8 motion to recalibrate device. This can be done at any time.' + '<br /> <br />Avoid locations with magnetic fields or metal objects as these may disorient the devices compass.',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.resetAlignment();\n    },\n    handleClickHover: function handleClickHover() {\n        this.state.augmentedVirtuality.toggleHoverHeight();\n    },\n    render: function render() {\n        var enabled = this.state.augmentedVirtuality.enabled;\n        var toggleImage = _Icon2.default.GLYPHS.arOff;\n        var toggleStyle = _augmented_virtuality_tool2.default.btn;\n        if (enabled) {\n            toggleImage = _Icon2.default.GLYPHS.arOn;\n            toggleStyle = _augmented_virtuality_tool2.default.btnPrimary;\n        }\n\n        var realignment = this.state.augmentedVirtuality.manualAlignment;\n        var realignmentStyle = _augmented_virtuality_tool2.default.btn;\n        if (realignment) {\n            realignmentStyle = _augmented_virtuality_tool2.default.btnBlink;\n        }\n\n        var hoverLevel = this.state.augmentedVirtuality.hoverLevel;\n        var hoverImage = _Icon2.default.GLYPHS.arHover0;\n        // Note: We use the image of the next level that we will be changing to, not the level the we are currently at.\n        switch (hoverLevel) {\n            case 0:\n                hoverImage = _Icon2.default.GLYPHS.arHover0;\n                break;\n            case 1:\n                hoverImage = _Icon2.default.GLYPHS.arHover1;\n                break;\n            case 2:\n                hoverImage = _Icon2.default.GLYPHS.arHover2;\n                break;\n        }\n\n        return this.props.terria.viewerMode !== _ViewerMode2.default.Leaflet ? _react2.default.createElement(\n            'div',\n            { className: _augmented_virtuality_tool2.default.augmentedVirtualityTool },\n            _react2.default.createElement(\n                'button',\n                { type: 'button', className: toggleStyle,\n                    title: 'augmented reality tool',\n                    onClick: this.handleClickAVTool },\n                _react2.default.createElement(_Icon2.default, { glyph: toggleImage })\n            ),\n            enabled ? [_react2.default.createElement(\n                'button',\n                { type: 'button', className: _augmented_virtuality_tool2.default.btn,\n                    title: 'toggle hover height',\n                    onClick: this.handleClickHover, key: '0'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: hoverImage })\n            ), !this.state.augmentedVirtuality.manualAlignmentSet ? _react2.default.createElement(\n                'button',\n                { type: 'button', className: realignmentStyle,\n                    title: 'toggle manual alignment',\n                    onClick: this.handleClickRealign, key: '1'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: _Icon2.default.GLYPHS.arRealign })\n            ) : null, this.state.augmentedVirtuality.manualAlignmentSet && !realignment ? _react2.default.createElement(\n                'button',\n                { type: 'button', className: _augmented_virtuality_tool2.default.btn,\n                    title: 'reset compass alignment',\n                    onClick: this.handleClickResetRealign, key: '2'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: _Icon2.default.GLYPHS.arResetAlignment })\n            ) : null] : null\n        ) : null;\n    }\n});\n\nmodule.exports = AugmentedVirtualityTool;\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// 2.TerriaMap.js","// removed by extract-text-webpack-plugin\nmodule.exports = {\"btn\":\"tjs-augmented_virtuality_tool__btn tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnPrimary\":\"tjs-augmented_virtuality_tool__btn-primary tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-blink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btnBlink\":\"tjs-augmented_virtuality_tool__btn-blink tjs-_buttons__btn tjs-_buttons__btn tjs-nav__btn tjs-_buttons__btn\",\"btn-primary--hover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"btnPrimaryHover\":\"tjs-augmented_virtuality_tool__btn-primary--hover\",\"blinker\":\"tjs-augmented_virtuality_tool__blinker\",\"toolButton\":\"tjs-augmented_virtuality_tool__toolButton\",\"augmentedVirtualityTool\":\"tjs-augmented_virtuality_tool__augmentedVirtualityTool tjs-tool_button__toolButton\"};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/terriajs/lib/ReactViews/Map/Navigation/augmented_virtuality_tool.scss\n// module id = 2276\n// module chunks = 2","'use strict';\n\nvar _defined = require('terriajs-cesium/Source/Core/defined');\n\nvar _defined2 = _interopRequireDefault(_defined);\n\nvar _defaultValue = require('terriajs-cesium/Source/Core/defaultValue');\n\nvar _defaultValue2 = _interopRequireDefault(_defaultValue);\n\nvar _knockout = require('terriajs-cesium/Source/ThirdParty/knockout');\n\nvar _knockout2 = _interopRequireDefault(_knockout);\n\nvar _Math = require('terriajs-cesium/Source/Core/Math.js');\n\nvar _Math2 = _interopRequireDefault(_Math);\n\nvar _Matrix = require('terriajs-cesium/Source/Core/Matrix3.js');\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nvar _Cartesian = require('terriajs-cesium/Source/Core/Cartesian3.js');\n\nvar _Cartesian2 = _interopRequireDefault(_Cartesian);\n\nvar _EllipsoidTerrainProvider = require('terriajs-cesium/Source/Core/EllipsoidTerrainProvider');\n\nvar _EllipsoidTerrainProvider2 = _interopRequireDefault(_EllipsoidTerrainProvider);\n\nvar _sampleTerrainMostDetailed = require('terriajs-cesium/Source/Core/sampleTerrainMostDetailed');\n\nvar _sampleTerrainMostDetailed2 = _interopRequireDefault(_sampleTerrainMostDetailed);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\r\n * Manages state for Augmented Virtuality mode.\r\n *\r\n * This mode uses the devices orientation sensors to change the viewers viewport to match the change in orientation.\r\n *\r\n * Term Augmented Virtuality:\r\n * \"The use of real-world sensor information (e.g., gyroscopes) to control a virtual environment is an additional form\r\n * of augmented virtuality, in which external inputs provide context for the virtual view.\"\r\n * {@link https://en.wikipedia.org/wiki/Mixed_reality}\r\n *\r\n * @alias AugmentedVirtuality\r\n * @constructor\r\n */\nvar AugmentedVirtuality = function AugmentedVirtuality(terria) {\n    var that = this;\n\n    this._terria = terria;\n\n    // Note: We create a persistant object and define a transient property, since knockout needs a persistant variable\n    //       to track, but for state we want a 'maybe' intervalId.\n    this._eventLoopState = {};\n\n    this._manualAlignment = false;\n\n    this._maximumUpdatesPerSecond = AugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND;\n\n    this._orientationUpdated = false;\n    this._alpha = 0;\n    this._beta = 0;\n    this._gamma = 0;\n    this._realignAlpha = 0;\n    this._realignHeading = 0;\n\n    // Set the default height to be the last height so that when we first toggle (and increment) we cycle and go to the first height.\n    this._hoverLevel = AugmentedVirtuality.PRESET_HEIGHTS.length - 1;\n\n    // Always run the device orientation event, this way as soon as we enable we know where we are and set the\n    // orientation rather then having to wait for the next update.\n    // The following is disabled because chrome does not currently support deviceorientationabsolute correctly:\n    // if ('ondeviceorientationabsolute' in window)\n    // {\n    //     window.addEventListener('deviceorientationabsolute', function(event) {that._orientationUpdate(event);} );\n    // }\n    // else\n    if ('ondeviceorientation' in window) {\n        window.addEventListener('deviceorientation', function (event) {\n            that._storeOrientation(event);\n        });\n    }\n\n    // Make the variables used by the object properties knockout observable so that changes in the state notify the UI\n    // and cause a UI update. Note: These are all of the variables used just by the getters (not the setters), since\n    // these unqiquely define what the current state is and are the only things that can effect/cause the state to change\n    // (note: _eventLoopState is hidden behind ._eventLoopRunning() ).\n    _knockout2.default.track(this, ['_eventLoopState', '_manualAlignment', '_maximumUpdatesPerSecond', '_realignAlpha', '_realignHeading', '_hoverLevel']);\n\n    // Note: The following properties are defined as knockout properties so that they can be used to trigger updates on the UI.\n    /**\r\n     * Gets or sets whether Augmented Virtuality mode is currently enabled (true) or not (false).\r\n     *\r\n     * Note: If {@link AugmentedVirtuality#manualAlignment} is enabled and the state is changed it will be disabled.\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {Boolean} enabled\r\n     */\n    _knockout2.default.defineProperty(this, 'enabled', {\n        get: function get() {\n            return this._eventLoopRunning() || this._manualAlignment;\n        },\n        set: function set(enable) {\n            if (enable !== true) {\n                enable = false;\n\n                this.resetAlignment();\n            }\n\n            if (enable !== this.enabled) {\n                // If we are changing the enabled state then disable manual alignment.\n                // We only do this if we are changing the enabled state so that the client can repeatedly call the\n                // setting without having any effect if they aren't changing the enabled state, but so that every time\n                // that the state is changed that the manual alignment is turned back off initally.\n                this._manualAlignment = false;\n\n                this._startEventLoop(enable);\n            }\n        }\n    });\n\n    /**\r\n     * Gets or sets whether manual realignment mode is currently enabled (true) or not (false).\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {Boolean} manualAlignment\r\n     */\n    _knockout2.default.defineProperty(this, 'manualAlignment', {\n        get: function get() {\n            return this._getManualAlignment();\n        },\n        set: function set(startEnd) {\n            this._setManualAlignment(startEnd);\n        }\n    });\n\n    /**\r\n     * Gets whether a manual realignment has been specified (true) or not (false).\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {Boolean} manualAlignmentSet\r\n     */\n    _knockout2.default.defineProperty(this, 'manualAlignmentSet', {\n        get: function get() {\n            return this._realignAlpha !== 0.0 || this._realignHeading !== 0.0;\n        }\n    });\n\n    /**\r\n     * Gets the index of the current hover level.\r\n     *\r\n     * Use <code>AugmentedVirtuality.PRESET_HEIGHTS.length</code> to find the total avaliable levels.\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {int} hoverLevel\r\n     */\n    _knockout2.default.defineProperty(this, 'hoverLevel', {\n        get: function get() {\n            return this._hoverLevel;\n        }\n    });\n\n    /**\r\n     * Gets or sets the the maximum number of times that the camera orientation will be updated per second. This is\r\n     * the number of camera orientation updates per seconds is capped to (explicitly the number of times the\r\n     * orientation is updated per second might be less but it won't be more then this number). We want the number of\r\n     * times that the orientation is updated capped so that we don't consume to much battery life updating to\r\n     * frequently, but responsiveness is still acceptable.\r\n     *\r\n     * @memberOf AugmentedVirtuality.prototype\r\n     * @member {Float} maximumUpdatesPerSecond\r\n     */\n    _knockout2.default.defineProperty(this, 'maximumUpdatesPerSecond', {\n        get: function get() {\n            return this._maximumUpdatesPerSecond;\n        },\n        set: function set(maximumUpdatesPerSecond) {\n            this._maximumUpdatesPerSecond = maximumUpdatesPerSecond;\n\n            // If we are currently enabled reset to update the timing interval used.\n            if (this._eventLoopRunning()) {\n                this._startEventLoop(false);\n                this._startEventLoop(true);\n            }\n        }\n    });\n\n    this.enabled = false;\n};\n\n/**\r\n * Gets the the maximum number of times that the camera orientation will be updated per second by default. This is the\r\n * number of camera orientation updates per seconds is capped to by default (explicitly the number of times the\r\n * orientation is updated per second might be less but it won't be more then this number). We want the number of times\r\n * that the orientation is updated capped so that we don't consume to much battery life updating to frequently, but\r\n * responsiveness is still acceptable.\r\n */\nAugmentedVirtuality.DEFAULT_MAXIMUM_UPDATES_PER_SECOND = 10.0;\n\n/**\r\n * The minimum height that the viewer is allowed to hover at.\r\n */\nAugmentedVirtuality.MINIMUM_HOVER_HEIGHT = 20.0;\n\n/* These are the heights that we can toggle through (in meters - above the surface height).\r\n */\nAugmentedVirtuality.PRESET_HEIGHTS = [1000, 250, 20];\n\n/**\r\n * Toggles whether the AugmentedVirutuality mode is enabled or disabled.\r\n */\nAugmentedVirtuality.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled;\n};\n\n/**\r\n * Toggles whether manual alignement is enabled or disabled.\r\n */\nAugmentedVirtuality.prototype.toggleManualAlignment = function () {\n    this.manualAlignment = !this.manualAlignment;\n};\n\n/**\r\n * Resets the alignment so that the alignement matches the devices absolute alignment.\r\n */\nAugmentedVirtuality.prototype.resetAlignment = function () {\n    this._orientationUpdated = true;\n    this._realignAlpha = 0;\n    this._realignHeading = 0;\n};\n\n/**\r\n * Toggles the viewer between a range of predefined heights, setting the cameras orientation so that it matches the\r\n * correct orientation.\r\n */\nAugmentedVirtuality.prototype.toggleHoverHeight = function () {\n    this._hoverLevel = (this._hoverLevel + 1) % AugmentedVirtuality.PRESET_HEIGHTS.length;\n\n    this.hover(AugmentedVirtuality.PRESET_HEIGHTS[this._hoverLevel]);\n};\n\n/**\r\n * Moves the viewer to a specified height, setting the orientation so that it matches the correct Augmented Virtuality\r\n * orientation.\r\n *\r\n * @param {Float} height The height in Meters above the globe surface. Note: If height is below\r\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} the height will be set to\r\n *                       {@link AugmentedVirtuality.MINIMUM_HOVER_HEIGHT} to avoid visual artifacts when the viewer\r\n *                       becomes to close to the surface.\r\n * @param {Cartographic} [position] The location to hover over. If not specified the current camera location will be used.\r\n * @param {Boolean} [flyTo=true] Whether to fly to the location (true) or whether to jump to the location (false).\r\n */\nAugmentedVirtuality.prototype.hover = function (height, position, flyTo) {\n    var that = this;\n\n    // Get access to the camera...if it is not avaliable we can't set the new height so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    if (!(0, _defined2.default)(position)) {\n        position = camera.positionCartographic.clone();\n    }\n\n    flyTo = (0, _defaultValue2.default)(flyTo, true);\n\n    // Clamp the minimum hover height (heights below this value could lead to poor visual artifacts).\n    if (height < AugmentedVirtuality.MINIMUM_HOVER_HEIGHT) {\n        height = AugmentedVirtuality.MINIMUM_HOVER_HEIGHT;\n    }\n\n    // Reset the viewer height.\n    function flyToHeight(surfaceHeight) {\n        if ((0, _defined2.default)(surfaceHeight)) {\n            height += surfaceHeight;\n        }\n\n        var newPosition = _Cartesian2.default.fromRadians(position.longitude, position.latitude, height);\n        var pose = that._getCurrentOrientation();\n        pose.destination = newPosition;\n\n        if (flyTo) {\n            camera.flyTo(pose);\n        } else {\n            camera.setView(pose);\n        }\n\n        // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n        // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n        // the view orientation does not visually update until the user manualy moves the camera position).\n        that._terria.currentViewer.notifyRepaintRequired();\n    }\n\n    // Get the ground surface height at this location and offset the height by it.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.scene) || !(0, _defined2.default)(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider2.default) {\n        // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n        flyToHeight(0);\n    } else {\n        var terrainProvider = this._terria.cesium.scene.terrainProvider;\n        (0, _sampleTerrainMostDetailed2.default)(terrainProvider, [position]).then(function (updatedPosition) {\n            flyToHeight(updatedPosition[0].height);\n        });\n    }\n};\n\n/**\r\n * Moves the viewer to a specified location while maintaining the current height and the correct Augmented Virtuality\r\n * orientation.\r\n *\r\n * @param {Cartographic} position The location to hover move to.\r\n * @param {Float} [maximumHeight] The maximum height (in meters) to cap the current camera height to (if this value is\r\n *                                specified and the viewer is above this height the camera will be restricted to this height).\r\n * @param {Boolean} [flyTo] Whether to fly to the location (true) or whether to jump to the location (false).\r\n *\r\n * When the manual alignment is enabled this function has no effect.\r\n */\nAugmentedVirtuality.prototype.moveTo = function (position, maximumHeight, flyTo) {\n    var that = this;\n\n    // If we are in manual alignment mode we don't allow the viewer to move (since this would create a jaring UX for most use cases).\n    if (this._manualAlignment) {\n        return;\n    }\n\n    // Get access to the camera...if it is not avaliable we can't get the current height (or set the new location) so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    var cameraPosition = camera.positionCartographic.clone();\n    var viewerHeight = cameraPosition.height;\n\n    // Reset the viewer height.\n    function moveToLocation(surfaceHeight) {\n        if (!(0, _defined2.default)(surfaceHeight)) {\n            surfaceHeight = 0;\n        }\n\n        var hoverHeight = viewerHeight - surfaceHeight;\n        if ((0, _defined2.default)(maximumHeight) && hoverHeight > maximumHeight) {\n\n            hoverHeight = maximumHeight;\n        }\n\n        that.hover(hoverHeight, position, flyTo);\n    }\n\n    // Get the ground surface height at this location and offset the height by it.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.scene) || !(0, _defined2.default)(this._terria.cesium.scene.terrainProvider) || this._terria.cesium.scene.terrainProvider instanceof _EllipsoidTerrainProvider2.default) {\n        // If we can't get access to the terrain provider or we can get access to the terrain provider and the provider is just the Ellipsoid then use the height of 0.\n        moveToLocation(undefined);\n    } else {\n        var terrainProvider = this._terria.cesium.scene.terrainProvider;\n        (0, _sampleTerrainMostDetailed2.default)(terrainProvider, [cameraPosition]).then(function (updatedPosition) {\n            moveToLocation(updatedPosition[0].height);\n        });\n    }\n};\n\n/**\r\n * Whether the user is currently setting a manual alignment.\r\n *\r\n * See also {@link AugmentedVirtuality#_setManualAlignment}.\r\n *\r\n * @return {Boolean} Whether the user is currently setting a manual alignment (true) or not (false).\r\n * @private\r\n */\nAugmentedVirtuality.prototype._getManualAlignment = function () {\n    return this.enabled && this._manualAlignment;\n};\n\n/**\r\n * Starts / stops manual alignment.\r\n *\r\n * When manual realignment is enabled it allows the user to specify a new origin for the alignment between the devices\r\n * physical and virtual alignment. When manual alignment is enabled the orientation is locked, to allow the user to\r\n * realign a visual landmark with a physical landmark.\r\n *\r\n * Note: Manual alignment is only done for the heading axis, this is because in practice we have found that the heading\r\n * axis is often out as mobile devices seem to have difficulty obtaining the compass direction, but seem to perform\r\n * relatively well in the other axes.\r\n *\r\n * Note: Realignment is only possible when AugmentedVirtuality is enabled. If AugmentedVirtuality is disabled while\r\n *       manual alignment is in progress it will be cancelled.\r\n *\r\n * See also {@link AugmentedVirtuality#_getManualAlignment}.\r\n *\r\n * @param {Boolean} startEnd Whether the user is starting (true) or ending (false) the realignment.\r\n * @private\r\n */\nAugmentedVirtuality.prototype._setManualAlignment = function (startEnd) {\n    // Only allow manual alignment changes when the module is enabled.\n    if (this.enabled !== true) {\n        return;\n    }\n\n    // Sanitise the input value to a boolean.\n    if (startEnd !== true) {\n        startEnd = false;\n    }\n\n    if (startEnd === false && (0, _defined2.default)(this._terria.cesium) && (0, _defined2.default)(this._terria.cesium.viewer) && (0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        this._realignAlpha = this._alpha;\n        this._realignHeading = _Math2.default.toDegrees(this._terria.cesium.viewer.camera.heading);\n    }\n\n    if (this._manualAlignment !== startEnd) {\n        this._manualAlignment = startEnd;\n        this._startEventLoop(!this._manualAlignment);\n    }\n};\n\n/**\r\n * Whether the event loop is currently running.\r\n *\r\n * @return {Boolean} enable Whether to start the event loop is currently running (true) or not (false).\r\n * @private\r\n */\nAugmentedVirtuality.prototype._eventLoopRunning = function () {\n    return (0, _defined2.default)(this._eventLoopState.intervalId);\n};\n\n/**\r\n * Start or stop the Augmented Virutuality mode event loop. When enabled the orientation will effect the cameras\r\n * view and when disabled the device orientation will not effect the cameras view.\r\n *\r\n * @param {Boolean} enable Whether to start the event loop (true) or stop the event loop (false).\r\n * @private\r\n */\nAugmentedVirtuality.prototype._startEventLoop = function (enable) {\n    // Are we actually changing the state?\n    if (this._eventLoopRunning() !== enable) {\n        if (enable === true) {\n            var that = this;\n\n            this._orientationUpdated = true;\n\n            var intervalMs = 1000 / this._maximumUpdatesPerSecond;\n            var id = setInterval(function () {\n                that._updateOrientation();\n            }, intervalMs);\n            this._eventLoopState = { intervalId: id };\n        } else {\n            clearInterval(this._eventLoopState.intervalId);\n            this._eventLoopState = {};\n        }\n    }\n};\n\n/**\r\n * Device orientation update event callback function. Stores the updated orientation into the object state.\r\n *\r\n * @param {Object} event Contains the updated device orientation (in .alpha, .beta, .gamma).\r\n * @private\r\n */\nAugmentedVirtuality.prototype._storeOrientation = function (event) {\n    this._alpha = event.alpha;\n    this._beta = event.beta;\n    this._gamma = event.gamma;\n    this._orientationUpdated = true;\n};\n\n/**\r\n * This function updates the cameras orientation using the last orientation recorded and the current screen orientation.\r\n *\r\n * @private\r\n */\nAugmentedVirtuality.prototype._updateOrientation = function () {\n\n    // Check if the screen orientation has changed and mark the orientation updated if it has.\n    var screenOrientation = this._getCurrentScreenOrientation();\n    if (screenOrientation !== this._lastScreenOrientation) {\n        this._orientationUpdated = true;\n    }\n    this._lastScreenOrientation = screenOrientation;\n\n    // Optomise by only updating the camera view if some part of the orientation calculation has changed.\n    if (!this._orientationUpdated) {\n        // The orientation has not been updated so don't waste time changing the orientation.\n        return;\n    }\n    this._orientationUpdated = false;\n\n    // Get access to the camera...if it is not avaliable we can't set the orientation so just return now.\n    if (!(0, _defined2.default)(this._terria.cesium) || !(0, _defined2.default)(this._terria.cesium.viewer) || !(0, _defined2.default)(this._terria.cesium.viewer.camera)) {\n\n        return;\n    }\n    var camera = this._terria.cesium.viewer.camera;\n\n    camera.setView(this._getCurrentOrientation(screenOrientation));\n\n    // Needed on mobile to make sure that the render is marked as dirty so that once AV mode has been disabled for a\n    // while and then is reenabled the .setView() function still has effect (otherwise dispite the call the .setView()\n    // the view orientation does not visually update until the user manualy moves the camera position).\n    this._terria.currentViewer.notifyRepaintRequired();\n};\n\n/**\r\n * Gets the current orientation stored in the object state and returns the roll, pitch and heading which can be used to set the cameras orientation.\r\n *\r\n * @param {Float} screenOrientation The screen orientation in degrees. Note: This field is optional, if supplied this value will be used for the screen orientation, otherwise the screen orientation will be obtained during the execution of this function.\r\n * @return {Object} A object with the roll, pitch and heading stored into the orientation.\r\n * @private\r\n */\nAugmentedVirtuality.prototype._getCurrentOrientation = function (screenOrientation) {\n    var alpha = this._alpha;\n    var beta = this._beta;\n    var gamma = this._gamma;\n\n    var realignAlpha = this._realignAlpha;\n    var realignHeading = this._realignHeading;\n\n    if (!(0, _defined2.default)(screenOrientation)) {\n        screenOrientation = this._getCurrentScreenOrientation();\n    }\n\n    return this._computeTerriaOrientation(alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading);\n};\n\n/**\r\n * Turns the orientation in the device frame of reference into an orientation suitable for specifying the Terria camera orientation.\r\n *\r\n * @param {Float} alpha The alpha value of the device orientation in degrees (this is the alpha value in the device's frame of reference).\r\n * @param {Float} beta  The beta  value of the device orientation in degrees (this is the beta  value in the device's frame of reference).\r\n * @param {Float} gamma The gamma value of the device orientation in degrees (this is the gamma value in the device's frame of reference).\r\n * @param {Float} screenOrientation The screen orientation in degrees.\r\n * @param {Float} realignAlpha   The value of the alpha   value the last time realignment was completed (supply zero if realignment is not supported).\r\n * @param {Float} realignHeading The value of the heading value the last time realignment was completed (supply zero if realignment is not supported).\r\n * @return {Object} An object with the roll, pitch and heading stored into the orientation.\r\n * @private\r\n */\nAugmentedVirtuality.prototype._computeTerriaOrientation = function (alpha, beta, gamma, screenOrientation, realignAlpha, realignHeading) {\n    // Note: The algorithmic formulation in this function is for simplicity of mathematical expression, readability,\n    //       maintainability and modification (i.e. it is easy to understand how to update or insert new offsets or features).\n    //       This is not the simplest form which clearly flows from the current formuleation and clearly simplify the\n    //       logic and operations but would increase the cost of future modifications and reduce the readability of the\n    //       expression. It is not anticipated that the current verbose implementation would have a significant impact\n    //       on performance or accuracy, but obviously there will be some impact on both and it can be simplified in\n    //       future if needed.\n\n    var rotation = _Matrix2.default.clone(_Matrix2.default.IDENTITY, rotation);\n    var rotationIncrement = void 0;\n\n    // Roll - Counteract the change in the (orientation) frame of reference when the screen is rotated and the\n    //        rotation lock is not on (the browser reorients the frame of reference to align with the new screen\n    //        orientation - where as we want it of the device relative to the world).\n    rotationIncrement = _Matrix2.default.fromRotationZ(_Math2.default.toRadians(screenOrientation));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Pitch - Align the device orientation frame with the ceasium orientation frame.\n    rotationIncrement = _Matrix2.default.fromRotationX(_Math2.default.toRadians(90));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Roll - Apply the deivce roll.\n    rotationIncrement = _Matrix2.default.fromRotationZ(_Math2.default.toRadians(gamma));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Pitch - Apply the deivce pitch.\n    rotationIncrement = _Matrix2.default.fromRotationX(_Math2.default.toRadians(-beta));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Heading - Apply the incremental deivce heading (from when start was last triggered).\n    rotationIncrement = _Matrix2.default.fromRotationY(_Math2.default.toRadians(-(alpha - realignAlpha)));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Heading - Use the offset when the orientation was last started.\n    //           Note: This is logically different from the alpha value and can only be applied here in the same way\n    //                 since Cesium camera is RPH (Heading last - most local). See Cesium camera rotation decomposition\n    //                 for more information on the Cesium camera formuleation.\n    rotationIncrement = _Matrix2.default.fromRotationY(_Math2.default.toRadians(realignHeading));\n    _Matrix2.default.multiply(rotation, rotationIncrement, rotation);\n\n    // Decompose rotation matrix into roll, pitch and heading to supply to Cesium camera.\n    //\n    // Use notation:\n    //     R = Roll, P = Pitch, H = Heading\n    //     SH = Sin(Heading), CH = Cos(Heading)\n    //\n    // Ceasium camera rotation = RPH:\n    //     [ CR, -SR,   0][  1,   0,   0][ CH,   0,  SH]   [CRCH-SRSPSH, -SRCP, CRSH-SRSPCH]\n    //     [ SR,  CR,   0][  0,  CP,  SP][  0,   1,   0] = [SRCH-CRSPSH,  CRCP, SRSH+CRSPCH]\n    //     [  0,   0,   1][  0, -SP,  CP][-SH,   0,  CH]   [   -CPSH   ,   -SP,    CPCH    ]\n    //     Note: The sign difference of the Sin terms in pitch is different to the standard right handed rotation since\n    //           Cesium rotates pitch in the left handed direction. Both heading and roll are right handed rotations.\n    //\n    // Use the following notation to refer to elements in the Cesium camera rotation matrix:\n    //     [R00, R10, R20]\n    //     [R01, R11, R21]\n    //     [R02, R12, R22]\n    //\n    // Also note: Tan(X) = Sin(X) / Cos(X)\n    //\n    // Decompose matrix:\n    //    H = ATan(Tan(H)) = ATan(Sin(H)/Cos(H)) = ATan (SH / CH) = ATan(CPSH/CPCH) = ATan (-R02 / R22)\n    //    R = ATan(Tan(R)) = ATan(Sin(R)/Cos(R)) = ATan (SR / CR) = ATan(SRCP/CRCP) = ATan (-R10 / R11)\n    //    P = ATan(Tan(P)) = ATan(Sin(P)/Cos(P)) = ATan (SP / CP)\n    //                                             SP = -R12\n    //                                             Need to find CP:\n    //                                                 CP = Sqrt(CP^2)\n    //                                                    = Sqrt(CP^2*(CH^2+SH^2))              Since: (Cos@^2 + Sin@^2) = 1\n    //                                                    = Sqrt((CP^2)*(CH^2) + (CP^2)*(SH^2)) Expand\n    //                                                    = Sqrt((CPCH)^2 + (CPSH)^2)           Since: N^2*M^2 = (NM)^2\n    //                                                    = Sqrt(R22^2 + (-R02)^2)              Substitute\n    //                                                    = Sqrt(R22^2 + R02^2)                 Since: (-N)^2 = N^2\n    //  So P = ATan (-R12 / Sqrt(R22^2 + R02^2))\n\n\n    // Simplify notation for readability:\n    var r10 = rotation[_Matrix2.default.COLUMN1ROW0];\n    var r11 = rotation[_Matrix2.default.COLUMN1ROW1];\n    var r02 = rotation[_Matrix2.default.COLUMN0ROW2];\n    var r12 = rotation[_Matrix2.default.COLUMN1ROW2];\n    var r22 = rotation[_Matrix2.default.COLUMN2ROW2];\n\n    var heading = _Math2.default.toDegrees(Math.atan2(-r02, r22));\n    var roll = _Math2.default.toDegrees(Math.atan2(-r10, r11));\n    var pitch = _Math2.default.toDegrees(Math.atan2(-r12, Math.sqrt(r02 * r02 + r22 * r22)));\n\n    // Create an object with the roll, pitch and heading we just computed.\n    return {\n        orientation: {\n            roll: _Math2.default.toRadians(roll),\n            pitch: _Math2.default.toRadians(pitch),\n            heading: _Math2.default.toRadians(heading)\n        }\n    };\n};\n\n/**\r\n * Gets the current screen orientation.\r\n *\r\n * @return {Object} The current screen orientation in degrees.\r\n * @private\r\n */\nAugmentedVirtuality.prototype._getCurrentScreenOrientation = function () {\n    if ((0, _defined2.default)(screen.orientation) && (0, _defined2.default)(screen.orientation.angle)) {\n        return screen.orientation.angle;\n    }\n\n    if ((0, _defined2.default)(window.orientation)) {\n        return window.orientation;\n    }\n\n    return 0;\n};\n\nmodule.exports = AugmentedVirtuality;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/terriajs/lib/Models/AugmentedVirtuality.js\n// module id = 2277\n// module chunks = 2","'use strict';\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _createReactClass = require('create-react-class');\n\nvar _createReactClass2 = _interopRequireDefault(_createReactClass);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _ObserveModelMixin = require('../../ObserveModelMixin');\n\nvar _ObserveModelMixin2 = _interopRequireDefault(_ObserveModelMixin);\n\nvar _augmented_virtuality_tool = require('./augmented_virtuality_tool.scss');\n\nvar _augmented_virtuality_tool2 = _interopRequireDefault(_augmented_virtuality_tool);\n\nvar _Icon = require('../../Icon');\n\nvar _Icon2 = _interopRequireDefault(_Icon);\n\nvar _ViewerMode = require('../../../Models/ViewerMode');\n\nvar _ViewerMode2 = _interopRequireDefault(_ViewerMode);\n\nvar _defined = require('terriajs-cesium/Source/Core/defined');\n\nvar _defined2 = _interopRequireDefault(_defined);\n\nvar _AugmentedVirtuality = require('../../../Models/AugmentedVirtuality');\n\nvar _AugmentedVirtuality2 = _interopRequireDefault(_AugmentedVirtuality);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar AugmentedVirtualityTool = (0, _createReactClass2.default)({\n    displayName: 'AugmentedVirtualityTool',\n    mixins: [_ObserveModelMixin2.default],\n\n    propTypes: {\n        terria: _propTypes2.default.object.isRequired,\n        viewState: _propTypes2.default.object.isRequired,\n        experimentalWarning: _propTypes2.default.bool\n    },\n\n    getInitialState: function getInitialState() {\n        return {\n            augmentedVirtuality: new _AugmentedVirtuality2.default(this.props.terria),\n            experimentalWarningShown: false,\n            realignHelpShown: false,\n            resetRealignHelpShown: false\n        };\n    },\n    handleClickAVTool: function handleClickAVTool() {\n        // Make the AugmentedVirtuality module avaliable elsewhere.\n        this.props.terria.augmentedVirtuality = this.state.augmentedVirtuality;\n\n        if ((0, _defined2.default)(this.props.experimentalWarning) && this.props.experimentalWarning !== false && !this.state.experimentalWarningShown) {\n\n            this.setState({ experimentalWarningShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Experimental Feature: Augmented Reality',\n                message: 'Augmented Reality mode is currently in beta. ' + 'This mode is only designed for use on the latest high end mobile devices. ' + '<br /><br />WARNING: This mode can consume a lot of data, please be mindful of data usage charges from your network provider. ' + '<br /><br />The accuracy of this mode depends on the accuracy of your mobile devices internal compass.',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.toggleEnabled();\n    },\n    handleClickRealign: function handleClickRealign() {\n        if (!this.state.realignHelpShown) {\n            this.setState({ realignHelpShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Manual Alignment',\n                message: 'Align your mobile device so that it corresponds with the maps current alignment, then click the blinking compass.' + ' If no landmarks to align with are currently visible on the map, you can move the map using' + ' drag and pinch actions until a recognisable landmark is visible before aligning the device with the map.' + '<br /><div><img width=\"100%\" src=\"./build/TerriaJS/images/ar-realign-guide.gif\" /></div>' + '<br />Tip: The sun or moon are often good landmarks to align with if you are in a location you aren\\x27t familiar with (be careful not to look at the sun - it can hurt your eyes).',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.toggleManualAlignment();\n    },\n    handleClickResetRealign: function handleClickResetRealign() {\n        if (!this.state.resetRealignHelpShown) {\n            this.setState({ resetRealignHelpShown: true });\n\n            this.props.viewState.notifications.push({\n                title: 'Reset Alignment',\n                message: 'Resetting to compass alignment. If the alignment doesn\\x27t match the real world try waving' + ' your device in a figure 8 motion to recalibrate device. This can be done at any time.' + '<br /> <br />Avoid locations with magnetic fields or metal objects as these may disorient the devices compass.',\n                confirmText: 'Got it'\n            });\n        }\n\n        this.state.augmentedVirtuality.resetAlignment();\n    },\n    handleClickHover: function handleClickHover() {\n        this.state.augmentedVirtuality.toggleHoverHeight();\n    },\n    render: function render() {\n        var enabled = this.state.augmentedVirtuality.enabled;\n        var toggleImage = _Icon2.default.GLYPHS.arOff;\n        var toggleStyle = _augmented_virtuality_tool2.default.btn;\n        if (enabled) {\n            toggleImage = _Icon2.default.GLYPHS.arOn;\n            toggleStyle = _augmented_virtuality_tool2.default.btnPrimary;\n        }\n\n        var realignment = this.state.augmentedVirtuality.manualAlignment;\n        var realignmentStyle = _augmented_virtuality_tool2.default.btn;\n        if (realignment) {\n            realignmentStyle = _augmented_virtuality_tool2.default.btnBlink;\n        }\n\n        var hoverLevel = this.state.augmentedVirtuality.hoverLevel;\n        var hoverImage = _Icon2.default.GLYPHS.arHover0;\n        // Note: We use the image of the next level that we will be changing to, not the level the we are currently at.\n        switch (hoverLevel) {\n            case 0:\n                hoverImage = _Icon2.default.GLYPHS.arHover0;\n                break;\n            case 1:\n                hoverImage = _Icon2.default.GLYPHS.arHover1;\n                break;\n            case 2:\n                hoverImage = _Icon2.default.GLYPHS.arHover2;\n                break;\n        }\n\n        return this.props.terria.viewerMode !== _ViewerMode2.default.Leaflet ? _react2.default.createElement(\n            'div',\n            { className: _augmented_virtuality_tool2.default.augmentedVirtualityTool },\n            _react2.default.createElement(\n                'button',\n                { type: 'button', className: toggleStyle,\n                    title: 'augmented reality tool',\n                    onClick: this.handleClickAVTool },\n                _react2.default.createElement(_Icon2.default, { glyph: toggleImage })\n            ),\n            enabled ? [_react2.default.createElement(\n                'button',\n                { type: 'button', className: _augmented_virtuality_tool2.default.btn,\n                    title: 'toggle hover height',\n                    onClick: this.handleClickHover, key: '0'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: hoverImage })\n            ), !this.state.augmentedVirtuality.manualAlignmentSet ? _react2.default.createElement(\n                'button',\n                { type: 'button', className: realignmentStyle,\n                    title: 'toggle manual alignment',\n                    onClick: this.handleClickRealign, key: '1'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: _Icon2.default.GLYPHS.arRealign })\n            ) : null, this.state.augmentedVirtuality.manualAlignmentSet && !realignment ? _react2.default.createElement(\n                'button',\n                { type: 'button', className: _augmented_virtuality_tool2.default.btn,\n                    title: 'reset compass alignment',\n                    onClick: this.handleClickResetRealign, key: '2'\n                },\n                _react2.default.createElement(_Icon2.default, { glyph: _Icon2.default.GLYPHS.arResetAlignment })\n            ) : null] : null\n        ) : null;\n    }\n});\n\nmodule.exports = AugmentedVirtualityTool;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/terriajs/lib/ReactViews/Map/Navigation/AugmentedVirtualityTool.jsx\n// module id = 806\n// module chunks = 2"],"sourceRoot":""}