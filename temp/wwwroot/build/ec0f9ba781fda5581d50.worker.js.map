{"version":3,"sources":["webpack:///ec0f9ba781fda5581d50.worker.js","webpack:///webpack/bootstrap ec0f9ba781fda5581d50","webpack:///./node_modules/terriajs-cesium/Source/ThirdParty/Workers/inflate.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","obj","InfTree","huft_build","b","bindex","e","t","hp","hn","v","a","f","g","h","j","k","mask","q","w","xp","y","z","Z_OK","BMAX","Z_DATA_ERROR","x","u","MANY","r","set","Z_BUF_ERROR","initWorkArea","vsize","Int32Array","length","subarray","that","this","inflate_trees_bits","bb","tb","result","msg","inflate_trees_dynamic","nl","nd","bl","bd","tl","td","cplens","cplext","Z_MEM_ERROR","cpdist","cpdext","InfCodes","inflate_fast","tl_index","td_index","tp","tp_index","ml","md","tp_index_t_3","next_in_index","avail_in","bitb","bitk","write","read","end","inflate_mask","read_byte","window","total_in","Z_STREAM_END","mode","tree","ltree","dtree","len","tree_index","need","lit","dist","lbits","dbits","ltree_index","dtree_index","init","START","proc","tindex","WASH","BADCODE","LEN","inflate_flush","LIT","LENEXT","DIST","DISTEXT","COPY","END","Z_STREAM_ERROR","free","InfBlocks","blens","TYPE","left","table","index","codes","last","hufts","inftree","Uint8Array","reset","CODES","next_out_index","avail_out","total_out","next_out","LENS","inflate_trees_fixed","TABLE","BADBLOCKS","STORED","DRY","read_buf","BTREE","border","DTREE","bl_","bd_","tl_","td_","DONELOCKS","set_dictionary","start","sync_point","Inflate","inflateReset","istate","BLOCKS","blocks","method","was","marker","wbits","inflateEnd","inflateInit","inflate","next_in","Z_FINISH","METHOD","Z_DEFLATED","BAD","FLAG","PRESET_DICT","DICT4","DICT3","DICT2","DICT1","DICT0","Z_NEED_DICT","DONE","inflateSetDictionary","dictionary","dictLength","inflateSync","mark","inflateSyncPoint","ZStream","Inflater","flush","Z_NO_FLUSH","buf","nomoreinput","append","data","onprogress","err","array","buffers","lastIndex","bufferIndex","bufferSize","push","forEach","chunk","fixed_tl","fixed_td","bits","ret","size","inflater","zip","addEventListener","event","message","postMessage","onappend","current","progress","onflush","self"],"mappings":"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","file":"ec0f9ba781fda5581d50.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"build/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright \r\n notice, this list of conditions and the following disclaimer in \r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\r\n * JZlib is based on zlib-1.1.3, so all credit should go authors\r\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\r\n * and contributors of zlib.\r\n */\r\n\r\n(function(obj) {\r\n\r\n\t// Global\r\n\tvar MAX_BITS = 15;\r\n\r\n\tvar Z_OK = 0;\r\n\tvar Z_STREAM_END = 1;\r\n\tvar Z_NEED_DICT = 2;\r\n\tvar Z_STREAM_ERROR = -2;\r\n\tvar Z_DATA_ERROR = -3;\r\n\tvar Z_MEM_ERROR = -4;\r\n\tvar Z_BUF_ERROR = -5;\r\n\r\n\tvar inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,\r\n\t\t\t0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];\r\n\r\n\tvar MANY = 1440;\r\n\r\n\t// JZlib version : \"1.0.2\"\r\n\tvar Z_NO_FLUSH = 0;\r\n\tvar Z_FINISH = 4;\r\n\r\n\t// InfTree\r\n\tvar fixed_bl = 9;\r\n\tvar fixed_bd = 5;\r\n\r\n\tvar fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,\r\n\t\t\t0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,\r\n\t\t\t0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,\r\n\t\t\t0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,\r\n\t\t\t0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,\r\n\t\t\t35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,\r\n\t\t\t26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,\r\n\t\t\t7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,\r\n\t\t\t8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,\r\n\t\t\t8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,\r\n\t\t\t0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,\r\n\t\t\t81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,\r\n\t\t\t0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,\r\n\t\t\t84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,\r\n\t\t\t0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,\r\n\t\t\t80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,\r\n\t\t\t0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,\r\n\t\t\t0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\r\n\t\t\t0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,\r\n\t\t\t193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,\r\n\t\t\t120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,\r\n\t\t\t227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,\r\n\t\t\t92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,\r\n\t\t\t249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,\r\n\t\t\t130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,\r\n\t\t\t181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,\r\n\t\t\t102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,\r\n\t\t\t221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,\r\n\t\t\t8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,\r\n\t\t\t147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,\r\n\t\t\t85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,\r\n\t\t\t235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,\r\n\t\t\t141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,\r\n\t\t\t167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,\r\n\t\t\t107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,\r\n\t\t\t207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,\r\n\t\t\t127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];\r\n\tvar fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,\r\n\t\t\t8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,\r\n\t\t\t24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];\r\n\r\n\t// Tables for deflate from PKZIP's appnote.txt.\r\n\tvar cplens = [ // Copy lengths for literal codes 257..285\r\n\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];\r\n\r\n\t// see note #13 above about 258\r\n\tvar cplext = [ // Extra bits for literal codes 257..285\r\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\r\n\t];\r\n\r\n\tvar cpdist = [ // Copy offsets for distance codes 0..29\r\n\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];\r\n\r\n\tvar cpdext = [ // Extra bits for distance codes\r\n\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\r\n\r\n\t// If BMAX needs to be larger than 16, then h and x[] should be uLong.\r\n\tvar BMAX = 15; // maximum bit length of any code\r\n\r\n\tfunction InfTree() {\r\n\t\tvar that = this;\r\n\r\n\t\tvar hn; // hufts used in space\r\n\t\tvar v; // work area for huft_build\r\n\t\tvar c; // bit length count table\r\n\t\tvar r; // table entry for structure assignment\r\n\t\tvar u; // table stack\r\n\t\tvar x; // bit offsets, then code stack\r\n\r\n\t\tfunction huft_build(b, // code lengths in bits (all assumed <=\r\n\t\t// BMAX)\r\n\t\tbindex, n, // number of codes (assumed <= 288)\r\n\t\ts, // number of simple-valued codes (0..s-1)\r\n\t\td, // list of base values for non-simple codes\r\n\t\te, // list of extra bits for non-simple codes\r\n\t\tt, // result: starting table\r\n\t\tm, // maximum lookup bits, returns actual\r\n\t\thp,// space for trees\r\n\t\thn,// hufts used in space\r\n\t\tv // working area: values in order of bit length\r\n\t\t) {\r\n\t\t\t// Given a list of code lengths and a maximum table size, make a set of\r\n\t\t\t// tables to decode that set of codes. Return Z_OK on success,\r\n\t\t\t// Z_BUF_ERROR\r\n\t\t\t// if the given code set is incomplete (the tables are still built in\r\n\t\t\t// this\r\n\t\t\t// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\r\n\t\t\t// of\r\n\t\t\t// lengths), or Z_MEM_ERROR if not enough memory.\r\n\r\n\t\t\tvar a; // counter for codes of length k\r\n\t\t\tvar f; // i repeats in table every f entries\r\n\t\t\tvar g; // maximum code length\r\n\t\t\tvar h; // table level\r\n\t\t\tvar i; // counter, current code\r\n\t\t\tvar j; // counter\r\n\t\t\tvar k; // number of bits in current code\r\n\t\t\tvar l; // bits per table (returned in m)\r\n\t\t\tvar mask; // (1 << w) - 1, to avoid cc -O bug on HP\r\n\t\t\tvar p; // pointer into c[], b[], or v[]\r\n\t\t\tvar q; // points to current table\r\n\t\t\tvar w; // bits before this table == (l * h)\r\n\t\t\tvar xp; // pointer into x\r\n\t\t\tvar y; // number of dummy codes added\r\n\t\t\tvar z; // number of entries in current table\r\n\r\n\t\t\t// Generate counts for each bit length\r\n\r\n\t\t\tp = 0;\r\n\t\t\ti = n;\r\n\t\t\tdo {\r\n\t\t\t\tc[b[bindex + p]]++;\r\n\t\t\t\tp++;\r\n\t\t\t\ti--; // assume all entries <= BMAX\r\n\t\t\t} while (i !== 0);\r\n\r\n\t\t\tif (c[0] == n) { // null input--all zero length codes\r\n\t\t\t\tt[0] = -1;\r\n\t\t\t\tm[0] = 0;\r\n\t\t\t\treturn Z_OK;\r\n\t\t\t}\r\n\r\n\t\t\t// Find minimum and maximum length, bound *m by those\r\n\t\t\tl = m[0];\r\n\t\t\tfor (j = 1; j <= BMAX; j++)\r\n\t\t\t\tif (c[j] !== 0)\r\n\t\t\t\t\tbreak;\r\n\t\t\tk = j; // minimum code length\r\n\t\t\tif (l < j) {\r\n\t\t\t\tl = j;\r\n\t\t\t}\r\n\t\t\tfor (i = BMAX; i !== 0; i--) {\r\n\t\t\t\tif (c[i] !== 0)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tg = i; // maximum code length\r\n\t\t\tif (l > i) {\r\n\t\t\t\tl = i;\r\n\t\t\t}\r\n\t\t\tm[0] = l;\r\n\r\n\t\t\t// Adjust last length count to fill out codes, if needed\r\n\t\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\r\n\t\t\t\tif ((y -= c[j]) < 0) {\r\n\t\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ((y -= c[i]) < 0) {\r\n\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t}\r\n\t\t\tc[i] += y;\r\n\r\n\t\t\t// Generate starting offsets into the value table for each length\r\n\t\t\tx[1] = j = 0;\r\n\t\t\tp = 1;\r\n\t\t\txp = 2;\r\n\t\t\twhile (--i !== 0) { // note that i == g from above\r\n\t\t\t\tx[xp] = (j += c[p]);\r\n\t\t\t\txp++;\r\n\t\t\t\tp++;\r\n\t\t\t}\r\n\r\n\t\t\t// Make a table of values in order of bit lengths\r\n\t\t\ti = 0;\r\n\t\t\tp = 0;\r\n\t\t\tdo {\r\n\t\t\t\tif ((j = b[bindex + p]) !== 0) {\r\n\t\t\t\t\tv[x[j]++] = i;\r\n\t\t\t\t}\r\n\t\t\t\tp++;\r\n\t\t\t} while (++i < n);\r\n\t\t\tn = x[g]; // set n to length of v\r\n\r\n\t\t\t// Generate the Huffman codes and for each, make the table entries\r\n\t\t\tx[0] = i = 0; // first Huffman code is zero\r\n\t\t\tp = 0; // grab values in bit order\r\n\t\t\th = -1; // no tables yet--level -1\r\n\t\t\tw = -l; // bits decoded == (l * h)\r\n\t\t\tu[0] = 0; // just to keep compilers happy\r\n\t\t\tq = 0; // ditto\r\n\t\t\tz = 0; // ditto\r\n\r\n\t\t\t// go through the bit lengths (k already is bits in shortest code)\r\n\t\t\tfor (; k <= g; k++) {\r\n\t\t\t\ta = c[k];\r\n\t\t\t\twhile (a-- !== 0) {\r\n\t\t\t\t\t// here i is the Huffman code of length k bits for value *p\r\n\t\t\t\t\t// make tables up to required level\r\n\t\t\t\t\twhile (k > w + l) {\r\n\t\t\t\t\t\th++;\r\n\t\t\t\t\t\tw += l; // previous table always l bits\r\n\t\t\t\t\t\t// compute minimum size table less than or equal to l bits\r\n\t\t\t\t\t\tz = g - w;\r\n\t\t\t\t\t\tz = (z > l) ? l : z; // table size upper limit\r\n\t\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\r\n\t\t\t\t\t\t\t// too few codes for\r\n\t\t\t\t\t\t\t// k-w bit table\r\n\t\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\r\n\t\t\t\t\t\t\txp = k;\r\n\t\t\t\t\t\t\tif (j < z) {\r\n\t\t\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\r\n\t\t\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp])\r\n\t\t\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\r\n\t\t\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tz = 1 << j; // table entries for j-bit table\r\n\r\n\t\t\t\t\t\t// allocate new table\r\n\t\t\t\t\t\tif (hn[0] + z > MANY) { // (note: doesn't matter for fixed)\r\n\t\t\t\t\t\t\treturn Z_DATA_ERROR; // overflow of MANY\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tu[h] = q = /* hp+ */hn[0]; // DEBUG\r\n\t\t\t\t\t\thn[0] += z;\r\n\r\n\t\t\t\t\t\t// connect to last table, if there is one\r\n\t\t\t\t\t\tif (h !== 0) {\r\n\t\t\t\t\t\t\tx[h] = i; // save pattern for backing up\r\n\t\t\t\t\t\t\tr[0] = /* (byte) */j; // bits in this table\r\n\t\t\t\t\t\t\tr[1] = /* (byte) */l; // bits to dump before this table\r\n\t\t\t\t\t\t\tj = i >>> (w - l);\r\n\t\t\t\t\t\t\tr[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\r\n\t\t\t\t\t\t\thp.set(r, (u[h - 1] + j) * 3);\r\n\t\t\t\t\t\t\t// to\r\n\t\t\t\t\t\t\t// last\r\n\t\t\t\t\t\t\t// table\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tt[0] = q; // first table is returned result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// set up table entry in r\r\n\t\t\t\t\tr[1] = /* (byte) */(k - w);\r\n\t\t\t\t\tif (p >= n) {\r\n\t\t\t\t\t\tr[0] = 128 + 64; // out of values--invalid code\r\n\t\t\t\t\t} else if (v[p] < s) {\r\n\t\t\t\t\t\tr[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\r\n\t\t\t\t\t\t// end-of-block\r\n\t\t\t\t\t\tr[2] = v[p++]; // simple code is just the value\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tr[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\r\n\t\t\t\t\t\t// up in lists\r\n\t\t\t\t\t\tr[2] = d[v[p++] - s];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// fill code-like entries with r\r\n\t\t\t\t\tf = 1 << (k - w);\r\n\t\t\t\t\tfor (j = i >>> w; j < z; j += f) {\r\n\t\t\t\t\t\thp.set(r, (q + j) * 3);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// backwards increment the k-bit code i\r\n\t\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\r\n\t\t\t\t\t\ti ^= j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti ^= j;\r\n\r\n\t\t\t\t\t// backup over finished tables\r\n\t\t\t\t\tmask = (1 << w) - 1; // needed on HP, cc -O bug\r\n\t\t\t\t\twhile ((i & mask) != x[h]) {\r\n\t\t\t\t\t\th--; // don't need to update q\r\n\t\t\t\t\t\tw -= l;\r\n\t\t\t\t\t\tmask = (1 << w) - 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Return Z_BUF_ERROR if we were given an incomplete table\r\n\t\t\treturn y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\r\n\t\t}\r\n\r\n\t\tfunction initWorkArea(vsize) {\r\n\t\t\tvar i;\r\n\t\t\tif (!hn) {\r\n\t\t\t\thn = []; // []; //new Array(1);\r\n\t\t\t\tv = []; // new Array(vsize);\r\n\t\t\t\tc = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\r\n\t\t\t\tr = []; // new Array(3);\r\n\t\t\t\tu = new Int32Array(BMAX); // new Array(BMAX);\r\n\t\t\t\tx = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\r\n\t\t\t}\r\n\t\t\tif (v.length < vsize) {\r\n\t\t\t\tv = []; // new Array(vsize);\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < vsize; i++) {\r\n\t\t\t\tv[i] = 0;\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < BMAX + 1; i++) {\r\n\t\t\t\tc[i] = 0;\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < 3; i++) {\r\n\t\t\t\tr[i] = 0;\r\n\t\t\t}\r\n\t\t\t// for(int i=0; i<BMAX; i++){u[i]=0;}\r\n\t\t\tu.set(c.subarray(0, BMAX), 0);\r\n\t\t\t// for(int i=0; i<BMAX+1; i++){x[i]=0;}\r\n\t\t\tx.set(c.subarray(0, BMAX + 1), 0);\r\n\t\t}\r\n\r\n\t\tthat.inflate_trees_bits = function(c, // 19 code lengths\r\n\t\tbb, // bits tree desired/actual depth\r\n\t\ttb, // bits tree result\r\n\t\thp, // space for trees\r\n\t\tz // for messages\r\n\t\t) {\r\n\t\t\tvar result;\r\n\t\t\tinitWorkArea(19);\r\n\t\t\thn[0] = 0;\r\n\t\t\tresult = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\r\n\r\n\t\t\tif (result == Z_DATA_ERROR) {\r\n\t\t\t\tz.msg = \"oversubscribed dynamic bit lengths tree\";\r\n\t\t\t} else if (result == Z_BUF_ERROR || bb[0] === 0) {\r\n\t\t\t\tz.msg = \"incomplete dynamic bit lengths tree\";\r\n\t\t\t\tresult = Z_DATA_ERROR;\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\tthat.inflate_trees_dynamic = function(nl, // number of literal/length codes\r\n\t\tnd, // number of distance codes\r\n\t\tc, // that many (total) code lengths\r\n\t\tbl, // literal desired/actual bit depth\r\n\t\tbd, // distance desired/actual bit depth\r\n\t\ttl, // literal/length tree result\r\n\t\ttd, // distance tree result\r\n\t\thp, // space for trees\r\n\t\tz // for messages\r\n\t\t) {\r\n\t\t\tvar result;\r\n\r\n\t\t\t// build literal/length tree\r\n\t\t\tinitWorkArea(288);\r\n\t\t\thn[0] = 0;\r\n\t\t\tresult = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\r\n\t\t\tif (result != Z_OK || bl[0] === 0) {\r\n\t\t\t\tif (result == Z_DATA_ERROR) {\r\n\t\t\t\t\tz.msg = \"oversubscribed literal/length tree\";\r\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\r\n\t\t\t\t\tz.msg = \"incomplete literal/length tree\";\r\n\t\t\t\t\tresult = Z_DATA_ERROR;\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\r\n\t\t\t// build distance tree\r\n\t\t\tinitWorkArea(288);\r\n\t\t\tresult = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\r\n\r\n\t\t\tif (result != Z_OK || (bd[0] === 0 && nl > 257)) {\r\n\t\t\t\tif (result == Z_DATA_ERROR) {\r\n\t\t\t\t\tz.msg = \"oversubscribed distance tree\";\r\n\t\t\t\t} else if (result == Z_BUF_ERROR) {\r\n\t\t\t\t\tz.msg = \"incomplete distance tree\";\r\n\t\t\t\t\tresult = Z_DATA_ERROR;\r\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\r\n\t\t\t\t\tz.msg = \"empty distance tree with lengths\";\r\n\t\t\t\t\tresult = Z_DATA_ERROR;\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tInfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth\r\n\tbd, // distance desired/actual bit depth\r\n\ttl,// literal/length tree result\r\n\ttd// distance tree result\r\n\t) {\r\n\t\tbl[0] = fixed_bl;\r\n\t\tbd[0] = fixed_bd;\r\n\t\ttl[0] = fixed_tl;\r\n\t\ttd[0] = fixed_td;\r\n\t\treturn Z_OK;\r\n\t};\r\n\r\n\t// InfCodes\r\n\r\n\t// waiting for \"i:\"=input,\r\n\t// \"o:\"=output,\r\n\t// \"x:\"=nothing\r\n\tvar START = 0; // x: set up for LEN\r\n\tvar LEN = 1; // i: get length/literal/eob next\r\n\tvar LENEXT = 2; // i: getting length extra (have base)\r\n\tvar DIST = 3; // i: get distance next\r\n\tvar DISTEXT = 4;// i: getting distance extra\r\n\tvar COPY = 5; // o: copying bytes in window, waiting\r\n\t// for space\r\n\tvar LIT = 6; // o: got literal, waiting for output\r\n\t// space\r\n\tvar WASH = 7; // o: got eob, possibly still output\r\n\t// waiting\r\n\tvar END = 8; // x: got eob and all data flushed\r\n\tvar BADCODE = 9;// x: got error\r\n\r\n\tfunction InfCodes() {\r\n\t\tvar that = this;\r\n\r\n\t\tvar mode; // current inflate_codes mode\r\n\r\n\t\t// mode dependent information\r\n\t\tvar len = 0;\r\n\r\n\t\tvar tree; // pointer into tree\r\n\t\tvar tree_index = 0;\r\n\t\tvar need = 0; // bits needed\r\n\r\n\t\tvar lit = 0;\r\n\r\n\t\t// if EXT or COPY, where and how much\r\n\t\tvar get = 0; // bits to get for extra\r\n\t\tvar dist = 0; // distance back to copy from\r\n\r\n\t\tvar lbits = 0; // ltree bits decoded per branch\r\n\t\tvar dbits = 0; // dtree bits decoder per branch\r\n\t\tvar ltree; // literal/length/eob tree\r\n\t\tvar ltree_index = 0; // literal/length/eob tree\r\n\t\tvar dtree; // distance tree\r\n\t\tvar dtree_index = 0; // distance tree\r\n\r\n\t\t// Called with number of bytes left to write in window at least 258\r\n\t\t// (the maximum string length) and number of input bytes available\r\n\t\t// at least ten. The ten bytes are six bytes for the longest length/\r\n\t\t// distance pair plus four bytes for overloading the bit buffer.\r\n\r\n\t\tfunction inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\r\n\t\t\tvar t; // temporary pointer\r\n\t\t\tvar tp; // temporary pointer\r\n\t\t\tvar tp_index; // temporary pointer\r\n\t\t\tvar e; // extra bits or operation\r\n\t\t\tvar b; // bit buffer\r\n\t\t\tvar k; // bits in bit buffer\r\n\t\t\tvar p; // input data pointer\r\n\t\t\tvar n; // bytes available there\r\n\t\t\tvar q; // output window write pointer\r\n\t\t\tvar m; // bytes to end of window or read pointer\r\n\t\t\tvar ml; // mask for literal/length tree\r\n\t\t\tvar md; // mask for distance tree\r\n\t\t\tvar c; // bytes to copy\r\n\t\t\tvar d; // distance back to copy from\r\n\t\t\tvar r; // copy source pointer\r\n\r\n\t\t\tvar tp_index_t_3; // (tp_index+t)*3\r\n\r\n\t\t\t// load input, output, bit values\r\n\t\t\tp = z.next_in_index;\r\n\t\t\tn = z.avail_in;\r\n\t\t\tb = s.bitb;\r\n\t\t\tk = s.bitk;\r\n\t\t\tq = s.write;\r\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t// initialize masks\r\n\t\t\tml = inflate_mask[bl];\r\n\t\t\tmd = inflate_mask[bd];\r\n\r\n\t\t\t// do until not enough input or output space for fast loop\r\n\t\t\tdo { // assume called with m >= 258 && n >= 10\r\n\t\t\t\t// get literal/length code\r\n\t\t\t\twhile (k < (20)) { // max bits for literal/length code\r\n\t\t\t\t\tn--;\r\n\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\tk += 8;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt = b & ml;\r\n\t\t\t\ttp = tl;\r\n\t\t\t\ttp_index = tl_index;\r\n\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\r\n\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\r\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\r\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\r\n\r\n\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\r\n\t\t\t\t\tm--;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\r\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\r\n\r\n\t\t\t\t\tif ((e & 16) !== 0) {\r\n\t\t\t\t\t\te &= 15;\r\n\t\t\t\t\t\tc = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);\r\n\r\n\t\t\t\t\t\tb >>= e;\r\n\t\t\t\t\t\tk -= e;\r\n\r\n\t\t\t\t\t\t// decode distance base of block to copy\r\n\t\t\t\t\t\twhile (k < (15)) { // max bits for distance code\r\n\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tt = b & md;\r\n\t\t\t\t\t\ttp = td;\r\n\t\t\t\t\t\ttp_index = td_index;\r\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\r\n\t\t\t\t\t\te = tp[tp_index_t_3];\r\n\r\n\t\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\r\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\r\n\r\n\t\t\t\t\t\t\tif ((e & 16) !== 0) {\r\n\t\t\t\t\t\t\t\t// get extra bits to add to distance base\r\n\t\t\t\t\t\t\t\te &= 15;\r\n\t\t\t\t\t\t\t\twhile (k < (e)) { // get extra bits (up to 13)\r\n\t\t\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\td = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\r\n\r\n\t\t\t\t\t\t\t\tb >>= (e);\r\n\t\t\t\t\t\t\t\tk -= (e);\r\n\r\n\t\t\t\t\t\t\t\t// do the copy\r\n\t\t\t\t\t\t\t\tm -= c;\r\n\t\t\t\t\t\t\t\tif (q >= d) { // offset before dest\r\n\t\t\t\t\t\t\t\t\t// just copy\r\n\t\t\t\t\t\t\t\t\tr = q - d;\r\n\t\t\t\t\t\t\t\t\tif (q - r > 0 && 2 > (q - r)) {\r\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // minimum\r\n\t\t\t\t\t\t\t\t\t\t// count is\r\n\t\t\t\t\t\t\t\t\t\t// three,\r\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // so unroll\r\n\t\t\t\t\t\t\t\t\t\t// loop a\r\n\t\t\t\t\t\t\t\t\t\t// little\r\n\t\t\t\t\t\t\t\t\t\tc -= 2;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + 2), q);\r\n\t\t\t\t\t\t\t\t\t\tq += 2;\r\n\t\t\t\t\t\t\t\t\t\tr += 2;\r\n\t\t\t\t\t\t\t\t\t\tc -= 2;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else { // else offset after destination\r\n\t\t\t\t\t\t\t\t\tr = q - d;\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tr += s.end; // force pointer in window\r\n\t\t\t\t\t\t\t\t\t} while (r < 0); // covers invalid distances\r\n\t\t\t\t\t\t\t\t\te = s.end - r;\r\n\t\t\t\t\t\t\t\t\tif (c > e) { // if source crosses,\r\n\t\t\t\t\t\t\t\t\t\tc -= e; // wrapped copy\r\n\t\t\t\t\t\t\t\t\t\tif (q - r > 0 && e > (q - r)) {\r\n\t\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\r\n\t\t\t\t\t\t\t\t\t\t\t} while (--e !== 0);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + e), q);\r\n\t\t\t\t\t\t\t\t\t\t\tq += e;\r\n\t\t\t\t\t\t\t\t\t\t\tr += e;\r\n\t\t\t\t\t\t\t\t\t\t\te = 0;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tr = 0; // copy rest from start of window\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// copy all or what's left\r\n\t\t\t\t\t\t\t\tif (q - r > 0 && c > (q - r)) {\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\r\n\t\t\t\t\t\t\t\t\t} while (--c !== 0);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + c), q);\r\n\t\t\t\t\t\t\t\t\tq += c;\r\n\t\t\t\t\t\t\t\t\tr += c;\r\n\t\t\t\t\t\t\t\t\tc = 0;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t} else if ((e & 64) === 0) {\r\n\t\t\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\r\n\t\t\t\t\t\t\t\tt += (b & inflate_mask[e]);\r\n\t\t\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\r\n\t\t\t\t\t\t\t\te = tp[tp_index_t_3];\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tz.msg = \"invalid distance code\";\r\n\r\n\t\t\t\t\t\t\t\tc = z.avail_in - n;\r\n\t\t\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\r\n\t\t\t\t\t\t\t\tn += c;\r\n\t\t\t\t\t\t\t\tp -= c;\r\n\t\t\t\t\t\t\t\tk -= c << 3;\r\n\r\n\t\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\ts.write = q;\r\n\r\n\t\t\t\t\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} while (true);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ((e & 64) === 0) {\r\n\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\r\n\t\t\t\t\t\tt += (b & inflate_mask[e]);\r\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\r\n\t\t\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\r\n\r\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\r\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\r\n\r\n\t\t\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\r\n\t\t\t\t\t\t\tm--;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ((e & 32) !== 0) {\r\n\r\n\t\t\t\t\t\tc = z.avail_in - n;\r\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\r\n\t\t\t\t\t\tn += c;\r\n\t\t\t\t\t\tp -= c;\r\n\t\t\t\t\t\tk -= c << 3;\r\n\r\n\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\ts.write = q;\r\n\r\n\t\t\t\t\t\treturn Z_STREAM_END;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tz.msg = \"invalid literal/length code\";\r\n\r\n\t\t\t\t\t\tc = z.avail_in - n;\r\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\r\n\t\t\t\t\t\tn += c;\r\n\t\t\t\t\t\tp -= c;\r\n\t\t\t\t\t\tk -= c << 3;\r\n\r\n\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\ts.write = q;\r\n\r\n\t\t\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (true);\r\n\t\t\t} while (m >= 258 && n >= 10);\r\n\r\n\t\t\t// not enough input or output--restore pointers and return\r\n\t\t\tc = z.avail_in - n;\r\n\t\t\tc = (k >> 3) < c ? k >> 3 : c;\r\n\t\t\tn += c;\r\n\t\t\tp -= c;\r\n\t\t\tk -= c << 3;\r\n\r\n\t\t\ts.bitb = b;\r\n\t\t\ts.bitk = k;\r\n\t\t\tz.avail_in = n;\r\n\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\tz.next_in_index = p;\r\n\t\t\ts.write = q;\r\n\r\n\t\t\treturn Z_OK;\r\n\t\t}\r\n\r\n\t\tthat.init = function(bl, bd, tl, tl_index, td, td_index) {\r\n\t\t\tmode = START;\r\n\t\t\tlbits = /* (byte) */bl;\r\n\t\t\tdbits = /* (byte) */bd;\r\n\t\t\tltree = tl;\r\n\t\t\tltree_index = tl_index;\r\n\t\t\tdtree = td;\r\n\t\t\tdtree_index = td_index;\r\n\t\t\ttree = null;\r\n\t\t};\r\n\r\n\t\tthat.proc = function(s, z, r) {\r\n\t\t\tvar j; // temporary storage\r\n\t\t\tvar tindex; // temporary pointer\r\n\t\t\tvar e; // extra bits or operation\r\n\t\t\tvar b = 0; // bit buffer\r\n\t\t\tvar k = 0; // bits in bit buffer\r\n\t\t\tvar p = 0; // input data pointer\r\n\t\t\tvar n; // bytes available there\r\n\t\t\tvar q; // output window write pointer\r\n\t\t\tvar m; // bytes to end of window or read pointer\r\n\t\t\tvar f; // pointer to copy strings from\r\n\r\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\r\n\t\t\tp = z.next_in_index;\r\n\t\t\tn = z.avail_in;\r\n\t\t\tb = s.bitb;\r\n\t\t\tk = s.bitk;\r\n\t\t\tq = s.write;\r\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t// process input and output based on current state\r\n\t\t\twhile (true) {\r\n\t\t\t\tswitch (mode) {\r\n\t\t\t\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\r\n\t\t\t\tcase START: // x: set up for LEN\r\n\t\t\t\t\tif (m >= 258 && n >= 10) {\r\n\r\n\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\tr = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\r\n\r\n\t\t\t\t\t\tp = z.next_in_index;\r\n\t\t\t\t\t\tn = z.avail_in;\r\n\t\t\t\t\t\tb = s.bitb;\r\n\t\t\t\t\t\tk = s.bitk;\r\n\t\t\t\t\t\tq = s.write;\r\n\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t\t\t\tif (r != Z_OK) {\r\n\t\t\t\t\t\t\tmode = r == Z_STREAM_END ? WASH : BADCODE;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tneed = lbits;\r\n\t\t\t\t\ttree = ltree;\r\n\t\t\t\t\ttree_index = ltree_index;\r\n\r\n\t\t\t\t\tmode = LEN;\r\n\t\t\t\tcase LEN: // i: get length/literal/eob next\r\n\t\t\t\t\tj = need;\r\n\r\n\t\t\t\t\twhile (k < (j)) {\r\n\t\t\t\t\t\tif (n !== 0)\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\r\n\r\n\t\t\t\t\tb >>>= (tree[tindex + 1]);\r\n\t\t\t\t\tk -= (tree[tindex + 1]);\r\n\r\n\t\t\t\t\te = tree[tindex];\r\n\r\n\t\t\t\t\tif (e === 0) { // literal\r\n\t\t\t\t\t\tlit = tree[tindex + 2];\r\n\t\t\t\t\t\tmode = LIT;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((e & 16) !== 0) { // length\r\n\t\t\t\t\t\tget = e & 15;\r\n\t\t\t\t\t\tlen = tree[tindex + 2];\r\n\t\t\t\t\t\tmode = LENEXT;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((e & 64) === 0) { // next table\r\n\t\t\t\t\t\tneed = e;\r\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((e & 32) !== 0) { // end of block\r\n\t\t\t\t\t\tmode = WASH;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = BADCODE; // invalid code\r\n\t\t\t\t\tz.msg = \"invalid literal/length code\";\r\n\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\r\n\t\t\t\tcase LENEXT: // i: getting length extra (have base)\r\n\t\t\t\t\tj = get;\r\n\r\n\t\t\t\t\twhile (k < (j)) {\r\n\t\t\t\t\t\tif (n !== 0)\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlen += (b & inflate_mask[j]);\r\n\r\n\t\t\t\t\tb >>= j;\r\n\t\t\t\t\tk -= j;\r\n\r\n\t\t\t\t\tneed = dbits;\r\n\t\t\t\t\ttree = dtree;\r\n\t\t\t\t\ttree_index = dtree_index;\r\n\t\t\t\t\tmode = DIST;\r\n\t\t\t\tcase DIST: // i: get distance next\r\n\t\t\t\t\tj = need;\r\n\r\n\t\t\t\t\twhile (k < (j)) {\r\n\t\t\t\t\t\tif (n !== 0)\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\r\n\r\n\t\t\t\t\tb >>= tree[tindex + 1];\r\n\t\t\t\t\tk -= tree[tindex + 1];\r\n\r\n\t\t\t\t\te = (tree[tindex]);\r\n\t\t\t\t\tif ((e & 16) !== 0) { // distance\r\n\t\t\t\t\t\tget = e & 15;\r\n\t\t\t\t\t\tdist = tree[tindex + 2];\r\n\t\t\t\t\t\tmode = DISTEXT;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((e & 64) === 0) { // next table\r\n\t\t\t\t\t\tneed = e;\r\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = BADCODE; // invalid code\r\n\t\t\t\t\tz.msg = \"invalid distance code\";\r\n\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\r\n\t\t\t\tcase DISTEXT: // i: getting distance extra\r\n\t\t\t\t\tj = get;\r\n\r\n\t\t\t\t\twhile (k < (j)) {\r\n\t\t\t\t\t\tif (n !== 0)\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdist += (b & inflate_mask[j]);\r\n\r\n\t\t\t\t\tb >>= j;\r\n\t\t\t\t\tk -= j;\r\n\r\n\t\t\t\t\tmode = COPY;\r\n\t\t\t\tcase COPY: // o: copying bytes in window, waiting for space\r\n\t\t\t\t\tf = q - dist;\r\n\t\t\t\t\twhile (f < 0) { // modulo window size-\"while\" instead\r\n\t\t\t\t\t\tf += s.end; // of \"if\" handles invalid distances\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile (len !== 0) {\r\n\r\n\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\r\n\t\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t\tq = s.write;\r\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\r\n\t\t\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ts.window[q++] = s.window[f++];\r\n\t\t\t\t\t\tm--;\r\n\r\n\t\t\t\t\t\tif (f == s.end)\r\n\t\t\t\t\t\t\tf = 0;\r\n\t\t\t\t\t\tlen--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = START;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LIT: // o: got literal, waiting for output space\r\n\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\r\n\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\r\n\t\t\t\t\t\t\tq = s.write;\r\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\r\n\t\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tr = Z_OK;\r\n\r\n\t\t\t\t\ts.window[q++] = /* (byte) */lit;\r\n\t\t\t\t\tm--;\r\n\r\n\t\t\t\t\tmode = START;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase WASH: // o: got eob, possibly more output\r\n\t\t\t\t\tif (k > 7) { // return unused byte, if any\r\n\t\t\t\t\t\tk -= 8;\r\n\t\t\t\t\t\tn++;\r\n\t\t\t\t\t\tp--; // can always return one\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\tr = s.inflate_flush(z, r);\r\n\t\t\t\t\tq = s.write;\r\n\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t\t\tif (s.read != s.write) {\r\n\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = END;\r\n\t\t\t\tcase END:\r\n\t\t\t\t\tr = Z_STREAM_END;\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\r\n\t\t\t\tcase BADCODE: // x: got error\r\n\r\n\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tr = Z_STREAM_ERROR;\r\n\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthat.free = function() {\r\n\t\t\t// ZFREE(z, c);\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// InfBlocks\r\n\r\n\t// Table for deflate from PKZIP's appnote.txt.\r\n\tvar border = [ // Order of the bit length code lengths\r\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\r\n\r\n\tvar TYPE = 0; // get type bits (3, including end bit)\r\n\tvar LENS = 1; // get lengths for stored\r\n\tvar STORED = 2;// processing stored block\r\n\tvar TABLE = 3; // get table lengths\r\n\tvar BTREE = 4; // get bit lengths tree for a dynamic\r\n\t// block\r\n\tvar DTREE = 5; // get length, distance trees for a\r\n\t// dynamic block\r\n\tvar CODES = 6; // processing fixed or dynamic block\r\n\tvar DRY = 7; // output remaining window bytes\r\n\tvar DONELOCKS = 8; // finished last block, done\r\n\tvar BADBLOCKS = 9; // ot a data error--stuck here\r\n\r\n\tfunction InfBlocks(z, w) {\r\n\t\tvar that = this;\r\n\r\n\t\tvar mode = TYPE; // current inflate_block mode\r\n\r\n\t\tvar left = 0; // if STORED, bytes left to copy\r\n\r\n\t\tvar table = 0; // table lengths (14 bits)\r\n\t\tvar index = 0; // index into blens (or border)\r\n\t\tvar blens; // bit lengths of codes\r\n\t\tvar bb = [ 0 ]; // bit length tree depth\r\n\t\tvar tb = [ 0 ]; // bit length decoding tree\r\n\r\n\t\tvar codes = new InfCodes(); // if CODES, current state\r\n\r\n\t\tvar last = 0; // true if this block is the last block\r\n\r\n\t\tvar hufts = new Int32Array(MANY * 3); // single malloc for tree space\r\n\t\tvar check = 0; // check on output\r\n\t\tvar inftree = new InfTree();\r\n\r\n\t\tthat.bitk = 0; // bits in bit buffer\r\n\t\tthat.bitb = 0; // bit buffer\r\n\t\tthat.window = new Uint8Array(w); // sliding window\r\n\t\tthat.end = w; // one byte after sliding window\r\n\t\tthat.read = 0; // window read pointer\r\n\t\tthat.write = 0; // window write pointer\r\n\r\n\t\tthat.reset = function(z, c) {\r\n\t\t\tif (c)\r\n\t\t\t\tc[0] = check;\r\n\t\t\t// if (mode == BTREE || mode == DTREE) {\r\n\t\t\t// }\r\n\t\t\tif (mode == CODES) {\r\n\t\t\t\tcodes.free(z);\r\n\t\t\t}\r\n\t\t\tmode = TYPE;\r\n\t\t\tthat.bitk = 0;\r\n\t\t\tthat.bitb = 0;\r\n\t\t\tthat.read = that.write = 0;\r\n\t\t};\r\n\r\n\t\tthat.reset(z, null);\r\n\r\n\t\t// copy as much as possible from the sliding window to the output area\r\n\t\tthat.inflate_flush = function(z, r) {\r\n\t\t\tvar n;\r\n\t\t\tvar p;\r\n\t\t\tvar q;\r\n\r\n\t\t\t// local copies of source and destination pointers\r\n\t\t\tp = z.next_out_index;\r\n\t\t\tq = that.read;\r\n\r\n\t\t\t// compute number of bytes to copy as far as end of window\r\n\t\t\tn = /* (int) */((q <= that.write ? that.write : that.end) - q);\r\n\t\t\tif (n > z.avail_out)\r\n\t\t\t\tn = z.avail_out;\r\n\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\r\n\t\t\t\tr = Z_OK;\r\n\r\n\t\t\t// update counters\r\n\t\t\tz.avail_out -= n;\r\n\t\t\tz.total_out += n;\r\n\r\n\t\t\t// copy as far as end of window\r\n\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\r\n\t\t\tp += n;\r\n\t\t\tq += n;\r\n\r\n\t\t\t// see if more to copy at beginning of window\r\n\t\t\tif (q == that.end) {\r\n\t\t\t\t// wrap pointers\r\n\t\t\t\tq = 0;\r\n\t\t\t\tif (that.write == that.end)\r\n\t\t\t\t\tthat.write = 0;\r\n\r\n\t\t\t\t// compute bytes to copy\r\n\t\t\t\tn = that.write - q;\r\n\t\t\t\tif (n > z.avail_out)\r\n\t\t\t\t\tn = z.avail_out;\r\n\t\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\r\n\t\t\t\t\tr = Z_OK;\r\n\r\n\t\t\t\t// update counters\r\n\t\t\t\tz.avail_out -= n;\r\n\t\t\t\tz.total_out += n;\r\n\r\n\t\t\t\t// copy\r\n\t\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\r\n\t\t\t\tp += n;\r\n\t\t\t\tq += n;\r\n\t\t\t}\r\n\r\n\t\t\t// update pointers\r\n\t\t\tz.next_out_index = p;\r\n\t\t\tthat.read = q;\r\n\r\n\t\t\t// done\r\n\t\t\treturn r;\r\n\t\t};\r\n\r\n\t\tthat.proc = function(z, r) {\r\n\t\t\tvar t; // temporary storage\r\n\t\t\tvar b; // bit buffer\r\n\t\t\tvar k; // bits in bit buffer\r\n\t\t\tvar p; // input data pointer\r\n\t\t\tvar n; // bytes available there\r\n\t\t\tvar q; // output window write pointer\r\n\t\t\tvar m; // bytes to end of window or read pointer\r\n\r\n\t\t\tvar i;\r\n\r\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\r\n\t\t\t// {\r\n\t\t\tp = z.next_in_index;\r\n\t\t\tn = z.avail_in;\r\n\t\t\tb = that.bitb;\r\n\t\t\tk = that.bitk;\r\n\t\t\t// }\r\n\t\t\t// {\r\n\t\t\tq = that.write;\r\n\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t// }\r\n\r\n\t\t\t// process input based on current state\r\n\t\t\t// DEBUG dtree\r\n\t\t\twhile (true) {\r\n\t\t\t\tswitch (mode) {\r\n\t\t\t\tcase TYPE:\r\n\r\n\t\t\t\t\twhile (k < (3)) {\r\n\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tt = /* (int) */(b & 7);\r\n\t\t\t\t\tlast = t & 1;\r\n\r\n\t\t\t\t\tswitch (t >>> 1) {\r\n\t\t\t\t\tcase 0: // stored\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\tt = k & 7; // go to byte boundary\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (t);\r\n\t\t\t\t\t\tk -= (t);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\tmode = LENS; // get length of stored block\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 1: // fixed\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tvar bl = []; // new Array(1);\r\n\t\t\t\t\t\tvar bd = []; // new Array(1);\r\n\t\t\t\t\t\tvar tl = [ [] ]; // new Array(1);\r\n\t\t\t\t\t\tvar td = [ [] ]; // new Array(1);\r\n\r\n\t\t\t\t\t\tInfTree.inflate_trees_fixed(bl, bd, tl, td);\r\n\t\t\t\t\t\tcodes.init(bl[0], bd[0], tl[0], 0, td[0], 0);\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\tmode = CODES;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2: // dynamic\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\tmode = TABLE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3: // illegal\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\tz.msg = \"invalid block type\";\r\n\t\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LENS:\r\n\r\n\t\t\t\t\twhile (k < (32)) {\r\n\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {\r\n\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\tz.msg = \"invalid stored block lengths\";\r\n\t\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tleft = (b & 0xffff);\r\n\t\t\t\t\tb = k = 0; // dump bits\r\n\t\t\t\t\tmode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase STORED:\r\n\t\t\t\t\tif (n === 0) {\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\r\n\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\tr = that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\tq = that.write;\r\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\r\n\t\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tr = Z_OK;\r\n\r\n\t\t\t\t\tt = left;\r\n\t\t\t\t\tif (t > n)\r\n\t\t\t\t\t\tt = n;\r\n\t\t\t\t\tif (t > m)\r\n\t\t\t\t\t\tt = m;\r\n\t\t\t\t\tthat.window.set(z.read_buf(p, t), q);\r\n\t\t\t\t\tp += t;\r\n\t\t\t\t\tn -= t;\r\n\t\t\t\t\tq += t;\r\n\t\t\t\t\tm -= t;\r\n\t\t\t\t\tif ((left -= t) !== 0)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tmode = last !== 0 ? DRY : TYPE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase TABLE:\r\n\r\n\t\t\t\t\twhile (k < (14)) {\r\n\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttable = t = (b & 0x3fff);\r\n\t\t\t\t\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\r\n\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\tz.msg = \"too many length or distance symbols\";\r\n\t\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\r\n\t\t\t\t\tif (!blens || blens.length < t) {\r\n\t\t\t\t\t\tblens = []; // new Array(t);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (i = 0; i < t; i++) {\r\n\t\t\t\t\t\t\tblens[i] = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// {\r\n\t\t\t\t\tb >>>= (14);\r\n\t\t\t\t\tk -= (14);\r\n\t\t\t\t\t// }\r\n\r\n\t\t\t\t\tindex = 0;\r\n\t\t\t\t\tmode = BTREE;\r\n\t\t\t\tcase BTREE:\r\n\t\t\t\t\twhile (index < 4 + (table >>> 10)) {\r\n\t\t\t\t\t\twhile (k < (3)) {\r\n\t\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tblens[border[index++]] = b & 7;\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile (index < 19) {\r\n\t\t\t\t\t\tblens[border[index++]] = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbb[0] = 7;\r\n\t\t\t\t\tt = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\r\n\t\t\t\t\tif (t != Z_OK) {\r\n\t\t\t\t\t\tr = t;\r\n\t\t\t\t\t\tif (r == Z_DATA_ERROR) {\r\n\t\t\t\t\t\t\tblens = null;\r\n\t\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tindex = 0;\r\n\t\t\t\t\tmode = DTREE;\r\n\t\t\t\tcase DTREE:\r\n\t\t\t\t\twhile (true) {\r\n\t\t\t\t\t\tt = table;\r\n\t\t\t\t\t\tif (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar j, c;\r\n\r\n\t\t\t\t\t\tt = bb[0];\r\n\r\n\t\t\t\t\t\twhile (k < (t)) {\r\n\t\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if (tb[0] == -1) {\r\n\t\t\t\t\t\t// System.err.println(\"null...\");\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\tt = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\r\n\t\t\t\t\t\tc = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\r\n\r\n\t\t\t\t\t\tif (c < 16) {\r\n\t\t\t\t\t\t\tb >>>= (t);\r\n\t\t\t\t\t\t\tk -= (t);\r\n\t\t\t\t\t\t\tblens[index++] = c;\r\n\t\t\t\t\t\t} else { // c == 16..18\r\n\t\t\t\t\t\t\ti = c == 18 ? 7 : c - 14;\r\n\t\t\t\t\t\t\tj = c == 18 ? 11 : 3;\r\n\r\n\t\t\t\t\t\t\twhile (k < (t + i)) {\r\n\t\t\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tb >>>= (t);\r\n\t\t\t\t\t\t\tk -= (t);\r\n\r\n\t\t\t\t\t\t\tj += (b & inflate_mask[i]);\r\n\r\n\t\t\t\t\t\t\tb >>>= (i);\r\n\t\t\t\t\t\t\tk -= (i);\r\n\r\n\t\t\t\t\t\t\ti = index;\r\n\t\t\t\t\t\t\tt = table;\r\n\t\t\t\t\t\t\tif (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {\r\n\t\t\t\t\t\t\t\tblens = null;\r\n\t\t\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\t\t\tz.msg = \"invalid bit length repeat\";\r\n\t\t\t\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tc = c == 16 ? blens[i - 1] : 0;\r\n\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\tblens[i++] = c;\r\n\t\t\t\t\t\t\t} while (--j !== 0);\r\n\t\t\t\t\t\t\tindex = i;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttb[0] = -1;\r\n\t\t\t\t\t// {\r\n\t\t\t\t\tvar bl_ = []; // new Array(1);\r\n\t\t\t\t\tvar bd_ = []; // new Array(1);\r\n\t\t\t\t\tvar tl_ = []; // new Array(1);\r\n\t\t\t\t\tvar td_ = []; // new Array(1);\r\n\t\t\t\t\tbl_[0] = 9; // must be <= 9 for lookahead assumptions\r\n\t\t\t\t\tbd_[0] = 6; // must be <= 9 for lookahead assumptions\r\n\r\n\t\t\t\t\tt = table;\r\n\t\t\t\t\tt = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\r\n\r\n\t\t\t\t\tif (t != Z_OK) {\r\n\t\t\t\t\t\tif (t == Z_DATA_ERROR) {\r\n\t\t\t\t\t\t\tblens = null;\r\n\t\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tr = t;\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcodes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);\r\n\t\t\t\t\t// }\r\n\t\t\t\t\tmode = CODES;\r\n\t\t\t\tcase CODES:\r\n\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\tthat.write = q;\r\n\r\n\t\t\t\t\tif ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\tcodes.free(z);\r\n\r\n\t\t\t\t\tp = z.next_in_index;\r\n\t\t\t\t\tn = z.avail_in;\r\n\t\t\t\t\tb = that.bitb;\r\n\t\t\t\t\tk = that.bitk;\r\n\t\t\t\t\tq = that.write;\r\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\r\n\t\t\t\t\tif (last === 0) {\r\n\t\t\t\t\t\tmode = TYPE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = DRY;\r\n\t\t\t\tcase DRY:\r\n\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\tr = that.inflate_flush(z, r);\r\n\t\t\t\t\tq = that.write;\r\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t\t\tif (that.read != that.write) {\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = DONELOCKS;\r\n\t\t\t\tcase DONELOCKS:\r\n\t\t\t\t\tr = Z_STREAM_END;\r\n\r\n\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\tcase BADBLOCKS:\r\n\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tr = Z_STREAM_ERROR;\r\n\r\n\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthat.free = function(z) {\r\n\t\t\tthat.reset(z, null);\r\n\t\t\tthat.window = null;\r\n\t\t\thufts = null;\r\n\t\t\t// ZFREE(z, s);\r\n\t\t};\r\n\r\n\t\tthat.set_dictionary = function(d, start, n) {\r\n\t\t\tthat.window.set(d.subarray(start, start + n), 0);\r\n\t\t\tthat.read = that.write = n;\r\n\t\t};\r\n\r\n\t\t// Returns true if inflate is currently at the end of a block generated\r\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH.\r\n\t\tthat.sync_point = function() {\r\n\t\t\treturn mode == LENS ? 1 : 0;\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// Inflate\r\n\r\n\t// preset dictionary flag in zlib header\r\n\tvar PRESET_DICT = 0x20;\r\n\r\n\tvar Z_DEFLATED = 8;\r\n\r\n\tvar METHOD = 0; // waiting for method byte\r\n\tvar FLAG = 1; // waiting for flag byte\r\n\tvar DICT4 = 2; // four dictionary check bytes to go\r\n\tvar DICT3 = 3; // three dictionary check bytes to go\r\n\tvar DICT2 = 4; // two dictionary check bytes to go\r\n\tvar DICT1 = 5; // one dictionary check byte to go\r\n\tvar DICT0 = 6; // waiting for inflateSetDictionary\r\n\tvar BLOCKS = 7; // decompressing blocks\r\n\tvar DONE = 12; // finished check, done\r\n\tvar BAD = 13; // got an error--stay here\r\n\r\n\tvar mark = [ 0, 0, 0xff, 0xff ];\r\n\r\n\tfunction Inflate() {\r\n\t\tvar that = this;\r\n\r\n\t\tthat.mode = 0; // current inflate mode\r\n\r\n\t\t// mode dependent information\r\n\t\tthat.method = 0; // if FLAGS, method byte\r\n\r\n\t\t// if CHECK, check values to compare\r\n\t\tthat.was = [ 0 ]; // new Array(1); // computed check value\r\n\t\tthat.need = 0; // stream check value\r\n\r\n\t\t// if BAD, inflateSync's marker bytes count\r\n\t\tthat.marker = 0;\r\n\r\n\t\t// mode independent information\r\n\t\tthat.wbits = 0; // log2(window size) (8..15, defaults to 15)\r\n\r\n\t\t// this.blocks; // current inflate_blocks state\r\n\r\n\t\tfunction inflateReset(z) {\r\n\t\t\tif (!z || !z.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\r\n\t\t\tz.total_in = z.total_out = 0;\r\n\t\t\tz.msg = null;\r\n\t\t\tz.istate.mode = BLOCKS;\r\n\t\t\tz.istate.blocks.reset(z, null);\r\n\t\t\treturn Z_OK;\r\n\t\t}\r\n\r\n\t\tthat.inflateEnd = function(z) {\r\n\t\t\tif (that.blocks)\r\n\t\t\t\tthat.blocks.free(z);\r\n\t\t\tthat.blocks = null;\r\n\t\t\t// ZFREE(z, z->state);\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t\tthat.inflateInit = function(z, w) {\r\n\t\t\tz.msg = null;\r\n\t\t\tthat.blocks = null;\r\n\r\n\t\t\t// set window size\r\n\t\t\tif (w < 8 || w > 15) {\r\n\t\t\t\tthat.inflateEnd(z);\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\t}\r\n\t\t\tthat.wbits = w;\r\n\r\n\t\t\tz.istate.blocks = new InfBlocks(z, 1 << w);\r\n\r\n\t\t\t// reset state\r\n\t\t\tinflateReset(z);\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t\tthat.inflate = function(z, f) {\r\n\t\t\tvar r;\r\n\t\t\tvar b;\r\n\r\n\t\t\tif (!z || !z.istate || !z.next_in)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\tf = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\r\n\t\t\tr = Z_BUF_ERROR;\r\n\t\t\twhile (true) {\r\n\t\t\t\t// System.out.println(\"mode: \"+z.istate.mode);\r\n\t\t\t\tswitch (z.istate.mode) {\r\n\t\t\t\tcase METHOD:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tif (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\r\n\t\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\t\tz.msg = \"unknown compression method\";\r\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((z.istate.method >> 4) + 8 > z.istate.wbits) {\r\n\t\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\t\tz.msg = \"invalid window size\";\r\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tz.istate.mode = FLAG;\r\n\t\t\t\tcase FLAG:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tb = (z.read_byte(z.next_in_index++)) & 0xff;\r\n\r\n\t\t\t\t\tif ((((z.istate.method << 8) + b) % 31) !== 0) {\r\n\t\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\t\tz.msg = \"incorrect header check\";\r\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ((b & PRESET_DICT) === 0) {\r\n\t\t\t\t\t\tz.istate.mode = BLOCKS;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tz.istate.mode = DICT4;\r\n\t\t\t\tcase DICT4:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tz.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;\r\n\t\t\t\t\tz.istate.mode = DICT3;\r\n\t\t\t\tcase DICT3:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;\r\n\t\t\t\t\tz.istate.mode = DICT2;\r\n\t\t\t\tcase DICT2:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;\r\n\t\t\t\t\tz.istate.mode = DICT1;\r\n\t\t\t\tcase DICT1:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tz.istate.need += (z.read_byte(z.next_in_index++) & 0xff);\r\n\t\t\t\t\tz.istate.mode = DICT0;\r\n\t\t\t\t\treturn Z_NEED_DICT;\r\n\t\t\t\tcase DICT0:\r\n\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\tz.msg = \"need dictionary\";\r\n\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\r\n\t\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\t\tcase BLOCKS:\r\n\r\n\t\t\t\t\tr = z.istate.blocks.proc(z, r);\r\n\t\t\t\t\tif (r == Z_DATA_ERROR) {\r\n\t\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (r == Z_OK) {\r\n\t\t\t\t\t\tr = f;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (r != Z_STREAM_END) {\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tr = f;\r\n\t\t\t\t\tz.istate.blocks.reset(z, z.istate.was);\r\n\t\t\t\t\tz.istate.mode = DONE;\r\n\t\t\t\tcase DONE:\r\n\t\t\t\t\treturn Z_STREAM_END;\r\n\t\t\t\tcase BAD:\r\n\t\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthat.inflateSetDictionary = function(z, dictionary, dictLength) {\r\n\t\t\tvar index = 0;\r\n\t\t\tvar length = dictLength;\r\n\t\t\tif (!z || !z.istate || z.istate.mode != DICT0)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\r\n\t\t\tif (length >= (1 << z.istate.wbits)) {\r\n\t\t\t\tlength = (1 << z.istate.wbits) - 1;\r\n\t\t\t\tindex = dictLength - length;\r\n\t\t\t}\r\n\t\t\tz.istate.blocks.set_dictionary(dictionary, index, length);\r\n\t\t\tz.istate.mode = BLOCKS;\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t\tthat.inflateSync = function(z) {\r\n\t\t\tvar n; // number of bytes to look at\r\n\t\t\tvar p; // pointer to bytes\r\n\t\t\tvar m; // number of marker bytes found in a row\r\n\t\t\tvar r, w; // temporaries to save total_in and total_out\r\n\r\n\t\t\t// set up\r\n\t\t\tif (!z || !z.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\tif (z.istate.mode != BAD) {\r\n\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\tz.istate.marker = 0;\r\n\t\t\t}\r\n\t\t\tif ((n = z.avail_in) === 0)\r\n\t\t\t\treturn Z_BUF_ERROR;\r\n\t\t\tp = z.next_in_index;\r\n\t\t\tm = z.istate.marker;\r\n\r\n\t\t\t// search\r\n\t\t\twhile (n !== 0 && m < 4) {\r\n\t\t\t\tif (z.read_byte(p) == mark[m]) {\r\n\t\t\t\t\tm++;\r\n\t\t\t\t} else if (z.read_byte(p) !== 0) {\r\n\t\t\t\t\tm = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tm = 4 - m;\r\n\t\t\t\t}\r\n\t\t\t\tp++;\r\n\t\t\t\tn--;\r\n\t\t\t}\r\n\r\n\t\t\t// restore\r\n\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\tz.next_in_index = p;\r\n\t\t\tz.avail_in = n;\r\n\t\t\tz.istate.marker = m;\r\n\r\n\t\t\t// return no joy or set up to restart on a new block\r\n\t\t\tif (m != 4) {\r\n\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t}\r\n\t\t\tr = z.total_in;\r\n\t\t\tw = z.total_out;\r\n\t\t\tinflateReset(z);\r\n\t\t\tz.total_in = r;\r\n\t\t\tz.total_out = w;\r\n\t\t\tz.istate.mode = BLOCKS;\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t\t// Returns true if inflate is currently at the end of a block generated\r\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\r\n\t\t// implementation to provide an additional safety check. PPP uses\r\n\t\t// Z_SYNC_FLUSH\r\n\t\t// but removes the length bytes of the resulting empty stored block. When\r\n\t\t// decompressing, PPP checks that at the end of input packet, inflate is\r\n\t\t// waiting for these length bytes.\r\n\t\tthat.inflateSyncPoint = function(z) {\r\n\t\t\tif (!z || !z.istate || !z.istate.blocks)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\treturn z.istate.blocks.sync_point();\r\n\t\t};\r\n\t}\r\n\r\n\t// ZStream\r\n\r\n\tfunction ZStream() {\r\n\t}\r\n\r\n\tZStream.prototype = {\r\n\t\tinflateInit : function(bits) {\r\n\t\t\tvar that = this;\r\n\t\t\tthat.istate = new Inflate();\r\n\t\t\tif (!bits)\r\n\t\t\t\tbits = MAX_BITS;\r\n\t\t\treturn that.istate.inflateInit(that, bits);\r\n\t\t},\r\n\r\n\t\tinflate : function(f) {\r\n\t\t\tvar that = this;\r\n\t\t\tif (!that.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\treturn that.istate.inflate(that, f);\r\n\t\t},\r\n\r\n\t\tinflateEnd : function() {\r\n\t\t\tvar that = this;\r\n\t\t\tif (!that.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\tvar ret = that.istate.inflateEnd(that);\r\n\t\t\tthat.istate = null;\r\n\t\t\treturn ret;\r\n\t\t},\r\n\r\n\t\tinflateSync : function() {\r\n\t\t\tvar that = this;\r\n\t\t\tif (!that.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\treturn that.istate.inflateSync(that);\r\n\t\t},\r\n\t\tinflateSetDictionary : function(dictionary, dictLength) {\r\n\t\t\tvar that = this;\r\n\t\t\tif (!that.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\treturn that.istate.inflateSetDictionary(that, dictionary, dictLength);\r\n\t\t},\r\n\t\tread_byte : function(start) {\r\n\t\t\tvar that = this;\r\n\t\t\treturn that.next_in.subarray(start, start + 1)[0];\r\n\t\t},\r\n\t\tread_buf : function(start, size) {\r\n\t\t\tvar that = this;\r\n\t\t\treturn that.next_in.subarray(start, start + size);\r\n\t\t}\r\n\t};\r\n\r\n\t// Inflater\r\n\r\n\tfunction Inflater() {\r\n\t\tvar that = this;\r\n\t\tvar z = new ZStream();\r\n\t\tvar bufsize = 512;\r\n\t\tvar flush = Z_NO_FLUSH;\r\n\t\tvar buf = new Uint8Array(bufsize);\r\n\t\tvar nomoreinput = false;\r\n\r\n\t\tz.inflateInit();\r\n\t\tz.next_out = buf;\r\n\r\n\t\tthat.append = function(data, onprogress) {\r\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\r\n\t\t\tif (data.length === 0)\r\n\t\t\t\treturn;\r\n\t\t\tz.next_in_index = 0;\r\n\t\t\tz.next_in = data;\r\n\t\t\tz.avail_in = data.length;\r\n\t\t\tdo {\r\n\t\t\t\tz.next_out_index = 0;\r\n\t\t\t\tz.avail_out = bufsize;\r\n\t\t\t\tif ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it\r\n\t\t\t\t\tz.next_in_index = 0;\r\n\t\t\t\t\tnomoreinput = true;\r\n\t\t\t\t}\r\n\t\t\t\terr = z.inflate(flush);\r\n\t\t\t\tif (nomoreinput && (err == Z_BUF_ERROR))\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif (err != Z_OK && err != Z_STREAM_END)\r\n\t\t\t\t\tthrow \"inflating: \" + z.msg;\r\n\t\t\t\tif ((nomoreinput || err == Z_STREAM_END) && (z.avail_in == data.length))\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif (z.next_out_index)\r\n\t\t\t\t\tif (z.next_out_index == bufsize)\r\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\r\n\t\t\t\tbufferSize += z.next_out_index;\r\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\r\n\t\t\t\t\tonprogress(z.next_in_index);\r\n\t\t\t\t\tlastIndex = z.next_in_index;\r\n\t\t\t\t}\r\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\r\n\t\t\tarray = new Uint8Array(bufferSize);\r\n\t\t\tbuffers.forEach(function(chunk) {\r\n\t\t\t\tarray.set(chunk, bufferIndex);\r\n\t\t\t\tbufferIndex += chunk.length;\r\n\t\t\t});\r\n\t\t\treturn array;\r\n\t\t};\r\n\t\tthat.flush = function() {\r\n\t\t\tz.inflateEnd();\r\n\t\t};\r\n\t}\r\n\r\n\tvar inflater;\r\n\r\n\tif (obj.zip)\r\n\t\tobj.zip.Inflater = Inflater;\r\n\telse {\r\n\t\tinflater = new Inflater();\r\n\t\tobj.addEventListener(\"message\", function(event) {\r\n\t\t\tvar message = event.data;\r\n\r\n\t\t\tif (message.append)\r\n\t\t\t\tobj.postMessage({\r\n\t\t\t\t\tonappend : true,\r\n\t\t\t\t\tdata : inflater.append(message.data, function(current) {\r\n\t\t\t\t\t\tobj.postMessage({\r\n\t\t\t\t\t\t\tprogress : true,\r\n\t\t\t\t\t\t\tcurrent : current\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t})\r\n\t\t\t\t});\r\n\t\t\tif (message.flush) {\r\n\t\t\t\tinflater.flush();\r\n\t\t\t\tobj.postMessage({\r\n\t\t\t\t\tonflush : true\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}, false);\r\n\t}\r\n\r\n})(self);\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ec0f9ba781fda5581d50.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"build/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ec0f9ba781fda5581d50","/*\r\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\r\n\r\n Redistribution and use in source and binary forms, with or without\r\n modification, are permitted provided that the following conditions are met:\r\n\r\n 1. Redistributions of source code must retain the above copyright notice,\r\n this list of conditions and the following disclaimer.\r\n\r\n 2. Redistributions in binary form must reproduce the above copyright \r\n notice, this list of conditions and the following disclaimer in \r\n the documentation and/or other materials provided with the distribution.\r\n\r\n 3. The names of the authors may not be used to endorse or promote products\r\n derived from this software without specific prior written permission.\r\n\r\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\r\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\r\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\r\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\r\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\r\n * JZlib is based on zlib-1.1.3, so all credit should go authors\r\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\r\n * and contributors of zlib.\r\n */\r\n\r\n(function(obj) {\r\n\r\n\t// Global\r\n\tvar MAX_BITS = 15;\r\n\r\n\tvar Z_OK = 0;\r\n\tvar Z_STREAM_END = 1;\r\n\tvar Z_NEED_DICT = 2;\r\n\tvar Z_STREAM_ERROR = -2;\r\n\tvar Z_DATA_ERROR = -3;\r\n\tvar Z_MEM_ERROR = -4;\r\n\tvar Z_BUF_ERROR = -5;\r\n\r\n\tvar inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,\r\n\t\t\t0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];\r\n\r\n\tvar MANY = 1440;\r\n\r\n\t// JZlib version : \"1.0.2\"\r\n\tvar Z_NO_FLUSH = 0;\r\n\tvar Z_FINISH = 4;\r\n\r\n\t// InfTree\r\n\tvar fixed_bl = 9;\r\n\tvar fixed_bd = 5;\r\n\r\n\tvar fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,\r\n\t\t\t0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,\r\n\t\t\t0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,\r\n\t\t\t0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,\r\n\t\t\t0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,\r\n\t\t\t35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,\r\n\t\t\t26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,\r\n\t\t\t7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,\r\n\t\t\t8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,\r\n\t\t\t8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,\r\n\t\t\t0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,\r\n\t\t\t81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,\r\n\t\t\t0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,\r\n\t\t\t84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,\r\n\t\t\t0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,\r\n\t\t\t80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,\r\n\t\t\t0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,\r\n\t\t\t0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\r\n\t\t\t0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,\r\n\t\t\t193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,\r\n\t\t\t120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,\r\n\t\t\t227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,\r\n\t\t\t92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,\r\n\t\t\t249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,\r\n\t\t\t130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,\r\n\t\t\t181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,\r\n\t\t\t102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,\r\n\t\t\t221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,\r\n\t\t\t8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,\r\n\t\t\t147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,\r\n\t\t\t85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,\r\n\t\t\t235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,\r\n\t\t\t141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,\r\n\t\t\t167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,\r\n\t\t\t107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,\r\n\t\t\t207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,\r\n\t\t\t127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];\r\n\tvar fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,\r\n\t\t\t8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,\r\n\t\t\t24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];\r\n\r\n\t// Tables for deflate from PKZIP's appnote.txt.\r\n\tvar cplens = [ // Copy lengths for literal codes 257..285\r\n\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];\r\n\r\n\t// see note #13 above about 258\r\n\tvar cplext = [ // Extra bits for literal codes 257..285\r\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\r\n\t];\r\n\r\n\tvar cpdist = [ // Copy offsets for distance codes 0..29\r\n\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];\r\n\r\n\tvar cpdext = [ // Extra bits for distance codes\r\n\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\r\n\r\n\t// If BMAX needs to be larger than 16, then h and x[] should be uLong.\r\n\tvar BMAX = 15; // maximum bit length of any code\r\n\r\n\tfunction InfTree() {\r\n\t\tvar that = this;\r\n\r\n\t\tvar hn; // hufts used in space\r\n\t\tvar v; // work area for huft_build\r\n\t\tvar c; // bit length count table\r\n\t\tvar r; // table entry for structure assignment\r\n\t\tvar u; // table stack\r\n\t\tvar x; // bit offsets, then code stack\r\n\r\n\t\tfunction huft_build(b, // code lengths in bits (all assumed <=\r\n\t\t// BMAX)\r\n\t\tbindex, n, // number of codes (assumed <= 288)\r\n\t\ts, // number of simple-valued codes (0..s-1)\r\n\t\td, // list of base values for non-simple codes\r\n\t\te, // list of extra bits for non-simple codes\r\n\t\tt, // result: starting table\r\n\t\tm, // maximum lookup bits, returns actual\r\n\t\thp,// space for trees\r\n\t\thn,// hufts used in space\r\n\t\tv // working area: values in order of bit length\r\n\t\t) {\r\n\t\t\t// Given a list of code lengths and a maximum table size, make a set of\r\n\t\t\t// tables to decode that set of codes. Return Z_OK on success,\r\n\t\t\t// Z_BUF_ERROR\r\n\t\t\t// if the given code set is incomplete (the tables are still built in\r\n\t\t\t// this\r\n\t\t\t// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\r\n\t\t\t// of\r\n\t\t\t// lengths), or Z_MEM_ERROR if not enough memory.\r\n\r\n\t\t\tvar a; // counter for codes of length k\r\n\t\t\tvar f; // i repeats in table every f entries\r\n\t\t\tvar g; // maximum code length\r\n\t\t\tvar h; // table level\r\n\t\t\tvar i; // counter, current code\r\n\t\t\tvar j; // counter\r\n\t\t\tvar k; // number of bits in current code\r\n\t\t\tvar l; // bits per table (returned in m)\r\n\t\t\tvar mask; // (1 << w) - 1, to avoid cc -O bug on HP\r\n\t\t\tvar p; // pointer into c[], b[], or v[]\r\n\t\t\tvar q; // points to current table\r\n\t\t\tvar w; // bits before this table == (l * h)\r\n\t\t\tvar xp; // pointer into x\r\n\t\t\tvar y; // number of dummy codes added\r\n\t\t\tvar z; // number of entries in current table\r\n\r\n\t\t\t// Generate counts for each bit length\r\n\r\n\t\t\tp = 0;\r\n\t\t\ti = n;\r\n\t\t\tdo {\r\n\t\t\t\tc[b[bindex + p]]++;\r\n\t\t\t\tp++;\r\n\t\t\t\ti--; // assume all entries <= BMAX\r\n\t\t\t} while (i !== 0);\r\n\r\n\t\t\tif (c[0] == n) { // null input--all zero length codes\r\n\t\t\t\tt[0] = -1;\r\n\t\t\t\tm[0] = 0;\r\n\t\t\t\treturn Z_OK;\r\n\t\t\t}\r\n\r\n\t\t\t// Find minimum and maximum length, bound *m by those\r\n\t\t\tl = m[0];\r\n\t\t\tfor (j = 1; j <= BMAX; j++)\r\n\t\t\t\tif (c[j] !== 0)\r\n\t\t\t\t\tbreak;\r\n\t\t\tk = j; // minimum code length\r\n\t\t\tif (l < j) {\r\n\t\t\t\tl = j;\r\n\t\t\t}\r\n\t\t\tfor (i = BMAX; i !== 0; i--) {\r\n\t\t\t\tif (c[i] !== 0)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tg = i; // maximum code length\r\n\t\t\tif (l > i) {\r\n\t\t\t\tl = i;\r\n\t\t\t}\r\n\t\t\tm[0] = l;\r\n\r\n\t\t\t// Adjust last length count to fill out codes, if needed\r\n\t\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\r\n\t\t\t\tif ((y -= c[j]) < 0) {\r\n\t\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ((y -= c[i]) < 0) {\r\n\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t}\r\n\t\t\tc[i] += y;\r\n\r\n\t\t\t// Generate starting offsets into the value table for each length\r\n\t\t\tx[1] = j = 0;\r\n\t\t\tp = 1;\r\n\t\t\txp = 2;\r\n\t\t\twhile (--i !== 0) { // note that i == g from above\r\n\t\t\t\tx[xp] = (j += c[p]);\r\n\t\t\t\txp++;\r\n\t\t\t\tp++;\r\n\t\t\t}\r\n\r\n\t\t\t// Make a table of values in order of bit lengths\r\n\t\t\ti = 0;\r\n\t\t\tp = 0;\r\n\t\t\tdo {\r\n\t\t\t\tif ((j = b[bindex + p]) !== 0) {\r\n\t\t\t\t\tv[x[j]++] = i;\r\n\t\t\t\t}\r\n\t\t\t\tp++;\r\n\t\t\t} while (++i < n);\r\n\t\t\tn = x[g]; // set n to length of v\r\n\r\n\t\t\t// Generate the Huffman codes and for each, make the table entries\r\n\t\t\tx[0] = i = 0; // first Huffman code is zero\r\n\t\t\tp = 0; // grab values in bit order\r\n\t\t\th = -1; // no tables yet--level -1\r\n\t\t\tw = -l; // bits decoded == (l * h)\r\n\t\t\tu[0] = 0; // just to keep compilers happy\r\n\t\t\tq = 0; // ditto\r\n\t\t\tz = 0; // ditto\r\n\r\n\t\t\t// go through the bit lengths (k already is bits in shortest code)\r\n\t\t\tfor (; k <= g; k++) {\r\n\t\t\t\ta = c[k];\r\n\t\t\t\twhile (a-- !== 0) {\r\n\t\t\t\t\t// here i is the Huffman code of length k bits for value *p\r\n\t\t\t\t\t// make tables up to required level\r\n\t\t\t\t\twhile (k > w + l) {\r\n\t\t\t\t\t\th++;\r\n\t\t\t\t\t\tw += l; // previous table always l bits\r\n\t\t\t\t\t\t// compute minimum size table less than or equal to l bits\r\n\t\t\t\t\t\tz = g - w;\r\n\t\t\t\t\t\tz = (z > l) ? l : z; // table size upper limit\r\n\t\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\r\n\t\t\t\t\t\t\t// too few codes for\r\n\t\t\t\t\t\t\t// k-w bit table\r\n\t\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\r\n\t\t\t\t\t\t\txp = k;\r\n\t\t\t\t\t\t\tif (j < z) {\r\n\t\t\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\r\n\t\t\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp])\r\n\t\t\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\r\n\t\t\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tz = 1 << j; // table entries for j-bit table\r\n\r\n\t\t\t\t\t\t// allocate new table\r\n\t\t\t\t\t\tif (hn[0] + z > MANY) { // (note: doesn't matter for fixed)\r\n\t\t\t\t\t\t\treturn Z_DATA_ERROR; // overflow of MANY\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tu[h] = q = /* hp+ */hn[0]; // DEBUG\r\n\t\t\t\t\t\thn[0] += z;\r\n\r\n\t\t\t\t\t\t// connect to last table, if there is one\r\n\t\t\t\t\t\tif (h !== 0) {\r\n\t\t\t\t\t\t\tx[h] = i; // save pattern for backing up\r\n\t\t\t\t\t\t\tr[0] = /* (byte) */j; // bits in this table\r\n\t\t\t\t\t\t\tr[1] = /* (byte) */l; // bits to dump before this table\r\n\t\t\t\t\t\t\tj = i >>> (w - l);\r\n\t\t\t\t\t\t\tr[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\r\n\t\t\t\t\t\t\thp.set(r, (u[h - 1] + j) * 3);\r\n\t\t\t\t\t\t\t// to\r\n\t\t\t\t\t\t\t// last\r\n\t\t\t\t\t\t\t// table\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tt[0] = q; // first table is returned result\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// set up table entry in r\r\n\t\t\t\t\tr[1] = /* (byte) */(k - w);\r\n\t\t\t\t\tif (p >= n) {\r\n\t\t\t\t\t\tr[0] = 128 + 64; // out of values--invalid code\r\n\t\t\t\t\t} else if (v[p] < s) {\r\n\t\t\t\t\t\tr[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\r\n\t\t\t\t\t\t// end-of-block\r\n\t\t\t\t\t\tr[2] = v[p++]; // simple code is just the value\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tr[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\r\n\t\t\t\t\t\t// up in lists\r\n\t\t\t\t\t\tr[2] = d[v[p++] - s];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// fill code-like entries with r\r\n\t\t\t\t\tf = 1 << (k - w);\r\n\t\t\t\t\tfor (j = i >>> w; j < z; j += f) {\r\n\t\t\t\t\t\thp.set(r, (q + j) * 3);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// backwards increment the k-bit code i\r\n\t\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\r\n\t\t\t\t\t\ti ^= j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti ^= j;\r\n\r\n\t\t\t\t\t// backup over finished tables\r\n\t\t\t\t\tmask = (1 << w) - 1; // needed on HP, cc -O bug\r\n\t\t\t\t\twhile ((i & mask) != x[h]) {\r\n\t\t\t\t\t\th--; // don't need to update q\r\n\t\t\t\t\t\tw -= l;\r\n\t\t\t\t\t\tmask = (1 << w) - 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Return Z_BUF_ERROR if we were given an incomplete table\r\n\t\t\treturn y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\r\n\t\t}\r\n\r\n\t\tfunction initWorkArea(vsize) {\r\n\t\t\tvar i;\r\n\t\t\tif (!hn) {\r\n\t\t\t\thn = []; // []; //new Array(1);\r\n\t\t\t\tv = []; // new Array(vsize);\r\n\t\t\t\tc = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\r\n\t\t\t\tr = []; // new Array(3);\r\n\t\t\t\tu = new Int32Array(BMAX); // new Array(BMAX);\r\n\t\t\t\tx = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\r\n\t\t\t}\r\n\t\t\tif (v.length < vsize) {\r\n\t\t\t\tv = []; // new Array(vsize);\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < vsize; i++) {\r\n\t\t\t\tv[i] = 0;\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < BMAX + 1; i++) {\r\n\t\t\t\tc[i] = 0;\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < 3; i++) {\r\n\t\t\t\tr[i] = 0;\r\n\t\t\t}\r\n\t\t\t// for(int i=0; i<BMAX; i++){u[i]=0;}\r\n\t\t\tu.set(c.subarray(0, BMAX), 0);\r\n\t\t\t// for(int i=0; i<BMAX+1; i++){x[i]=0;}\r\n\t\t\tx.set(c.subarray(0, BMAX + 1), 0);\r\n\t\t}\r\n\r\n\t\tthat.inflate_trees_bits = function(c, // 19 code lengths\r\n\t\tbb, // bits tree desired/actual depth\r\n\t\ttb, // bits tree result\r\n\t\thp, // space for trees\r\n\t\tz // for messages\r\n\t\t) {\r\n\t\t\tvar result;\r\n\t\t\tinitWorkArea(19);\r\n\t\t\thn[0] = 0;\r\n\t\t\tresult = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\r\n\r\n\t\t\tif (result == Z_DATA_ERROR) {\r\n\t\t\t\tz.msg = \"oversubscribed dynamic bit lengths tree\";\r\n\t\t\t} else if (result == Z_BUF_ERROR || bb[0] === 0) {\r\n\t\t\t\tz.msg = \"incomplete dynamic bit lengths tree\";\r\n\t\t\t\tresult = Z_DATA_ERROR;\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t};\r\n\r\n\t\tthat.inflate_trees_dynamic = function(nl, // number of literal/length codes\r\n\t\tnd, // number of distance codes\r\n\t\tc, // that many (total) code lengths\r\n\t\tbl, // literal desired/actual bit depth\r\n\t\tbd, // distance desired/actual bit depth\r\n\t\ttl, // literal/length tree result\r\n\t\ttd, // distance tree result\r\n\t\thp, // space for trees\r\n\t\tz // for messages\r\n\t\t) {\r\n\t\t\tvar result;\r\n\r\n\t\t\t// build literal/length tree\r\n\t\t\tinitWorkArea(288);\r\n\t\t\thn[0] = 0;\r\n\t\t\tresult = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\r\n\t\t\tif (result != Z_OK || bl[0] === 0) {\r\n\t\t\t\tif (result == Z_DATA_ERROR) {\r\n\t\t\t\t\tz.msg = \"oversubscribed literal/length tree\";\r\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\r\n\t\t\t\t\tz.msg = \"incomplete literal/length tree\";\r\n\t\t\t\t\tresult = Z_DATA_ERROR;\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\r\n\t\t\t// build distance tree\r\n\t\t\tinitWorkArea(288);\r\n\t\t\tresult = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\r\n\r\n\t\t\tif (result != Z_OK || (bd[0] === 0 && nl > 257)) {\r\n\t\t\t\tif (result == Z_DATA_ERROR) {\r\n\t\t\t\t\tz.msg = \"oversubscribed distance tree\";\r\n\t\t\t\t} else if (result == Z_BUF_ERROR) {\r\n\t\t\t\t\tz.msg = \"incomplete distance tree\";\r\n\t\t\t\t\tresult = Z_DATA_ERROR;\r\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\r\n\t\t\t\t\tz.msg = \"empty distance tree with lengths\";\r\n\t\t\t\t\tresult = Z_DATA_ERROR;\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tInfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth\r\n\tbd, // distance desired/actual bit depth\r\n\ttl,// literal/length tree result\r\n\ttd// distance tree result\r\n\t) {\r\n\t\tbl[0] = fixed_bl;\r\n\t\tbd[0] = fixed_bd;\r\n\t\ttl[0] = fixed_tl;\r\n\t\ttd[0] = fixed_td;\r\n\t\treturn Z_OK;\r\n\t};\r\n\r\n\t// InfCodes\r\n\r\n\t// waiting for \"i:\"=input,\r\n\t// \"o:\"=output,\r\n\t// \"x:\"=nothing\r\n\tvar START = 0; // x: set up for LEN\r\n\tvar LEN = 1; // i: get length/literal/eob next\r\n\tvar LENEXT = 2; // i: getting length extra (have base)\r\n\tvar DIST = 3; // i: get distance next\r\n\tvar DISTEXT = 4;// i: getting distance extra\r\n\tvar COPY = 5; // o: copying bytes in window, waiting\r\n\t// for space\r\n\tvar LIT = 6; // o: got literal, waiting for output\r\n\t// space\r\n\tvar WASH = 7; // o: got eob, possibly still output\r\n\t// waiting\r\n\tvar END = 8; // x: got eob and all data flushed\r\n\tvar BADCODE = 9;// x: got error\r\n\r\n\tfunction InfCodes() {\r\n\t\tvar that = this;\r\n\r\n\t\tvar mode; // current inflate_codes mode\r\n\r\n\t\t// mode dependent information\r\n\t\tvar len = 0;\r\n\r\n\t\tvar tree; // pointer into tree\r\n\t\tvar tree_index = 0;\r\n\t\tvar need = 0; // bits needed\r\n\r\n\t\tvar lit = 0;\r\n\r\n\t\t// if EXT or COPY, where and how much\r\n\t\tvar get = 0; // bits to get for extra\r\n\t\tvar dist = 0; // distance back to copy from\r\n\r\n\t\tvar lbits = 0; // ltree bits decoded per branch\r\n\t\tvar dbits = 0; // dtree bits decoder per branch\r\n\t\tvar ltree; // literal/length/eob tree\r\n\t\tvar ltree_index = 0; // literal/length/eob tree\r\n\t\tvar dtree; // distance tree\r\n\t\tvar dtree_index = 0; // distance tree\r\n\r\n\t\t// Called with number of bytes left to write in window at least 258\r\n\t\t// (the maximum string length) and number of input bytes available\r\n\t\t// at least ten. The ten bytes are six bytes for the longest length/\r\n\t\t// distance pair plus four bytes for overloading the bit buffer.\r\n\r\n\t\tfunction inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\r\n\t\t\tvar t; // temporary pointer\r\n\t\t\tvar tp; // temporary pointer\r\n\t\t\tvar tp_index; // temporary pointer\r\n\t\t\tvar e; // extra bits or operation\r\n\t\t\tvar b; // bit buffer\r\n\t\t\tvar k; // bits in bit buffer\r\n\t\t\tvar p; // input data pointer\r\n\t\t\tvar n; // bytes available there\r\n\t\t\tvar q; // output window write pointer\r\n\t\t\tvar m; // bytes to end of window or read pointer\r\n\t\t\tvar ml; // mask for literal/length tree\r\n\t\t\tvar md; // mask for distance tree\r\n\t\t\tvar c; // bytes to copy\r\n\t\t\tvar d; // distance back to copy from\r\n\t\t\tvar r; // copy source pointer\r\n\r\n\t\t\tvar tp_index_t_3; // (tp_index+t)*3\r\n\r\n\t\t\t// load input, output, bit values\r\n\t\t\tp = z.next_in_index;\r\n\t\t\tn = z.avail_in;\r\n\t\t\tb = s.bitb;\r\n\t\t\tk = s.bitk;\r\n\t\t\tq = s.write;\r\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t// initialize masks\r\n\t\t\tml = inflate_mask[bl];\r\n\t\t\tmd = inflate_mask[bd];\r\n\r\n\t\t\t// do until not enough input or output space for fast loop\r\n\t\t\tdo { // assume called with m >= 258 && n >= 10\r\n\t\t\t\t// get literal/length code\r\n\t\t\t\twhile (k < (20)) { // max bits for literal/length code\r\n\t\t\t\t\tn--;\r\n\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\tk += 8;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt = b & ml;\r\n\t\t\t\ttp = tl;\r\n\t\t\t\ttp_index = tl_index;\r\n\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\r\n\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\r\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\r\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\r\n\r\n\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\r\n\t\t\t\t\tm--;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tdo {\r\n\r\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\r\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\r\n\r\n\t\t\t\t\tif ((e & 16) !== 0) {\r\n\t\t\t\t\t\te &= 15;\r\n\t\t\t\t\t\tc = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);\r\n\r\n\t\t\t\t\t\tb >>= e;\r\n\t\t\t\t\t\tk -= e;\r\n\r\n\t\t\t\t\t\t// decode distance base of block to copy\r\n\t\t\t\t\t\twhile (k < (15)) { // max bits for distance code\r\n\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tt = b & md;\r\n\t\t\t\t\t\ttp = td;\r\n\t\t\t\t\t\ttp_index = td_index;\r\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\r\n\t\t\t\t\t\te = tp[tp_index_t_3];\r\n\r\n\t\t\t\t\t\tdo {\r\n\r\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\r\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\r\n\r\n\t\t\t\t\t\t\tif ((e & 16) !== 0) {\r\n\t\t\t\t\t\t\t\t// get extra bits to add to distance base\r\n\t\t\t\t\t\t\t\te &= 15;\r\n\t\t\t\t\t\t\t\twhile (k < (e)) { // get extra bits (up to 13)\r\n\t\t\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\td = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\r\n\r\n\t\t\t\t\t\t\t\tb >>= (e);\r\n\t\t\t\t\t\t\t\tk -= (e);\r\n\r\n\t\t\t\t\t\t\t\t// do the copy\r\n\t\t\t\t\t\t\t\tm -= c;\r\n\t\t\t\t\t\t\t\tif (q >= d) { // offset before dest\r\n\t\t\t\t\t\t\t\t\t// just copy\r\n\t\t\t\t\t\t\t\t\tr = q - d;\r\n\t\t\t\t\t\t\t\t\tif (q - r > 0 && 2 > (q - r)) {\r\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // minimum\r\n\t\t\t\t\t\t\t\t\t\t// count is\r\n\t\t\t\t\t\t\t\t\t\t// three,\r\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // so unroll\r\n\t\t\t\t\t\t\t\t\t\t// loop a\r\n\t\t\t\t\t\t\t\t\t\t// little\r\n\t\t\t\t\t\t\t\t\t\tc -= 2;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + 2), q);\r\n\t\t\t\t\t\t\t\t\t\tq += 2;\r\n\t\t\t\t\t\t\t\t\t\tr += 2;\r\n\t\t\t\t\t\t\t\t\t\tc -= 2;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else { // else offset after destination\r\n\t\t\t\t\t\t\t\t\tr = q - d;\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\tr += s.end; // force pointer in window\r\n\t\t\t\t\t\t\t\t\t} while (r < 0); // covers invalid distances\r\n\t\t\t\t\t\t\t\t\te = s.end - r;\r\n\t\t\t\t\t\t\t\t\tif (c > e) { // if source crosses,\r\n\t\t\t\t\t\t\t\t\t\tc -= e; // wrapped copy\r\n\t\t\t\t\t\t\t\t\t\tif (q - r > 0 && e > (q - r)) {\r\n\t\t\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\r\n\t\t\t\t\t\t\t\t\t\t\t} while (--e !== 0);\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + e), q);\r\n\t\t\t\t\t\t\t\t\t\t\tq += e;\r\n\t\t\t\t\t\t\t\t\t\t\tr += e;\r\n\t\t\t\t\t\t\t\t\t\t\te = 0;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tr = 0; // copy rest from start of window\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// copy all or what's left\r\n\t\t\t\t\t\t\t\tif (q - r > 0 && c > (q - r)) {\r\n\t\t\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\r\n\t\t\t\t\t\t\t\t\t} while (--c !== 0);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + c), q);\r\n\t\t\t\t\t\t\t\t\tq += c;\r\n\t\t\t\t\t\t\t\t\tr += c;\r\n\t\t\t\t\t\t\t\t\tc = 0;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t} else if ((e & 64) === 0) {\r\n\t\t\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\r\n\t\t\t\t\t\t\t\tt += (b & inflate_mask[e]);\r\n\t\t\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\r\n\t\t\t\t\t\t\t\te = tp[tp_index_t_3];\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tz.msg = \"invalid distance code\";\r\n\r\n\t\t\t\t\t\t\t\tc = z.avail_in - n;\r\n\t\t\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\r\n\t\t\t\t\t\t\t\tn += c;\r\n\t\t\t\t\t\t\t\tp -= c;\r\n\t\t\t\t\t\t\t\tk -= c << 3;\r\n\r\n\t\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\ts.write = q;\r\n\r\n\t\t\t\t\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} while (true);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ((e & 64) === 0) {\r\n\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\r\n\t\t\t\t\t\tt += (b & inflate_mask[e]);\r\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\r\n\t\t\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\r\n\r\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\r\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\r\n\r\n\t\t\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\r\n\t\t\t\t\t\t\tm--;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ((e & 32) !== 0) {\r\n\r\n\t\t\t\t\t\tc = z.avail_in - n;\r\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\r\n\t\t\t\t\t\tn += c;\r\n\t\t\t\t\t\tp -= c;\r\n\t\t\t\t\t\tk -= c << 3;\r\n\r\n\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\ts.write = q;\r\n\r\n\t\t\t\t\t\treturn Z_STREAM_END;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tz.msg = \"invalid literal/length code\";\r\n\r\n\t\t\t\t\t\tc = z.avail_in - n;\r\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\r\n\t\t\t\t\t\tn += c;\r\n\t\t\t\t\t\tp -= c;\r\n\t\t\t\t\t\tk -= c << 3;\r\n\r\n\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\ts.write = q;\r\n\r\n\t\t\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (true);\r\n\t\t\t} while (m >= 258 && n >= 10);\r\n\r\n\t\t\t// not enough input or output--restore pointers and return\r\n\t\t\tc = z.avail_in - n;\r\n\t\t\tc = (k >> 3) < c ? k >> 3 : c;\r\n\t\t\tn += c;\r\n\t\t\tp -= c;\r\n\t\t\tk -= c << 3;\r\n\r\n\t\t\ts.bitb = b;\r\n\t\t\ts.bitk = k;\r\n\t\t\tz.avail_in = n;\r\n\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\tz.next_in_index = p;\r\n\t\t\ts.write = q;\r\n\r\n\t\t\treturn Z_OK;\r\n\t\t}\r\n\r\n\t\tthat.init = function(bl, bd, tl, tl_index, td, td_index) {\r\n\t\t\tmode = START;\r\n\t\t\tlbits = /* (byte) */bl;\r\n\t\t\tdbits = /* (byte) */bd;\r\n\t\t\tltree = tl;\r\n\t\t\tltree_index = tl_index;\r\n\t\t\tdtree = td;\r\n\t\t\tdtree_index = td_index;\r\n\t\t\ttree = null;\r\n\t\t};\r\n\r\n\t\tthat.proc = function(s, z, r) {\r\n\t\t\tvar j; // temporary storage\r\n\t\t\tvar tindex; // temporary pointer\r\n\t\t\tvar e; // extra bits or operation\r\n\t\t\tvar b = 0; // bit buffer\r\n\t\t\tvar k = 0; // bits in bit buffer\r\n\t\t\tvar p = 0; // input data pointer\r\n\t\t\tvar n; // bytes available there\r\n\t\t\tvar q; // output window write pointer\r\n\t\t\tvar m; // bytes to end of window or read pointer\r\n\t\t\tvar f; // pointer to copy strings from\r\n\r\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\r\n\t\t\tp = z.next_in_index;\r\n\t\t\tn = z.avail_in;\r\n\t\t\tb = s.bitb;\r\n\t\t\tk = s.bitk;\r\n\t\t\tq = s.write;\r\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t// process input and output based on current state\r\n\t\t\twhile (true) {\r\n\t\t\t\tswitch (mode) {\r\n\t\t\t\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\r\n\t\t\t\tcase START: // x: set up for LEN\r\n\t\t\t\t\tif (m >= 258 && n >= 10) {\r\n\r\n\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\tr = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\r\n\r\n\t\t\t\t\t\tp = z.next_in_index;\r\n\t\t\t\t\t\tn = z.avail_in;\r\n\t\t\t\t\t\tb = s.bitb;\r\n\t\t\t\t\t\tk = s.bitk;\r\n\t\t\t\t\t\tq = s.write;\r\n\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t\t\t\tif (r != Z_OK) {\r\n\t\t\t\t\t\t\tmode = r == Z_STREAM_END ? WASH : BADCODE;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tneed = lbits;\r\n\t\t\t\t\ttree = ltree;\r\n\t\t\t\t\ttree_index = ltree_index;\r\n\r\n\t\t\t\t\tmode = LEN;\r\n\t\t\t\tcase LEN: // i: get length/literal/eob next\r\n\t\t\t\t\tj = need;\r\n\r\n\t\t\t\t\twhile (k < (j)) {\r\n\t\t\t\t\t\tif (n !== 0)\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\r\n\r\n\t\t\t\t\tb >>>= (tree[tindex + 1]);\r\n\t\t\t\t\tk -= (tree[tindex + 1]);\r\n\r\n\t\t\t\t\te = tree[tindex];\r\n\r\n\t\t\t\t\tif (e === 0) { // literal\r\n\t\t\t\t\t\tlit = tree[tindex + 2];\r\n\t\t\t\t\t\tmode = LIT;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((e & 16) !== 0) { // length\r\n\t\t\t\t\t\tget = e & 15;\r\n\t\t\t\t\t\tlen = tree[tindex + 2];\r\n\t\t\t\t\t\tmode = LENEXT;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((e & 64) === 0) { // next table\r\n\t\t\t\t\t\tneed = e;\r\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((e & 32) !== 0) { // end of block\r\n\t\t\t\t\t\tmode = WASH;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = BADCODE; // invalid code\r\n\t\t\t\t\tz.msg = \"invalid literal/length code\";\r\n\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\r\n\t\t\t\tcase LENEXT: // i: getting length extra (have base)\r\n\t\t\t\t\tj = get;\r\n\r\n\t\t\t\t\twhile (k < (j)) {\r\n\t\t\t\t\t\tif (n !== 0)\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlen += (b & inflate_mask[j]);\r\n\r\n\t\t\t\t\tb >>= j;\r\n\t\t\t\t\tk -= j;\r\n\r\n\t\t\t\t\tneed = dbits;\r\n\t\t\t\t\ttree = dtree;\r\n\t\t\t\t\ttree_index = dtree_index;\r\n\t\t\t\t\tmode = DIST;\r\n\t\t\t\tcase DIST: // i: get distance next\r\n\t\t\t\t\tj = need;\r\n\r\n\t\t\t\t\twhile (k < (j)) {\r\n\t\t\t\t\t\tif (n !== 0)\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\r\n\r\n\t\t\t\t\tb >>= tree[tindex + 1];\r\n\t\t\t\t\tk -= tree[tindex + 1];\r\n\r\n\t\t\t\t\te = (tree[tindex]);\r\n\t\t\t\t\tif ((e & 16) !== 0) { // distance\r\n\t\t\t\t\t\tget = e & 15;\r\n\t\t\t\t\t\tdist = tree[tindex + 2];\r\n\t\t\t\t\t\tmode = DISTEXT;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((e & 64) === 0) { // next table\r\n\t\t\t\t\t\tneed = e;\r\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = BADCODE; // invalid code\r\n\t\t\t\t\tz.msg = \"invalid distance code\";\r\n\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\r\n\t\t\t\tcase DISTEXT: // i: getting distance extra\r\n\t\t\t\t\tj = get;\r\n\r\n\t\t\t\t\twhile (k < (j)) {\r\n\t\t\t\t\t\tif (n !== 0)\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdist += (b & inflate_mask[j]);\r\n\r\n\t\t\t\t\tb >>= j;\r\n\t\t\t\t\tk -= j;\r\n\r\n\t\t\t\t\tmode = COPY;\r\n\t\t\t\tcase COPY: // o: copying bytes in window, waiting for space\r\n\t\t\t\t\tf = q - dist;\r\n\t\t\t\t\twhile (f < 0) { // modulo window size-\"while\" instead\r\n\t\t\t\t\t\tf += s.end; // of \"if\" handles invalid distances\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile (len !== 0) {\r\n\r\n\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\r\n\t\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t\tq = s.write;\r\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\r\n\t\t\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ts.window[q++] = s.window[f++];\r\n\t\t\t\t\t\tm--;\r\n\r\n\t\t\t\t\t\tif (f == s.end)\r\n\t\t\t\t\t\t\tf = 0;\r\n\t\t\t\t\t\tlen--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = START;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LIT: // o: got literal, waiting for output space\r\n\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\r\n\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\r\n\t\t\t\t\t\t\tq = s.write;\r\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\r\n\t\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tr = Z_OK;\r\n\r\n\t\t\t\t\ts.window[q++] = /* (byte) */lit;\r\n\t\t\t\t\tm--;\r\n\r\n\t\t\t\t\tmode = START;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase WASH: // o: got eob, possibly more output\r\n\t\t\t\t\tif (k > 7) { // return unused byte, if any\r\n\t\t\t\t\t\tk -= 8;\r\n\t\t\t\t\t\tn++;\r\n\t\t\t\t\t\tp--; // can always return one\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\tr = s.inflate_flush(z, r);\r\n\t\t\t\t\tq = s.write;\r\n\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\r\n\r\n\t\t\t\t\tif (s.read != s.write) {\r\n\t\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\ts.write = q;\r\n\t\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = END;\r\n\t\t\t\tcase END:\r\n\t\t\t\t\tr = Z_STREAM_END;\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\r\n\t\t\t\tcase BADCODE: // x: got error\r\n\r\n\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tr = Z_STREAM_ERROR;\r\n\r\n\t\t\t\t\ts.bitb = b;\r\n\t\t\t\t\ts.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\ts.write = q;\r\n\t\t\t\t\treturn s.inflate_flush(z, r);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthat.free = function() {\r\n\t\t\t// ZFREE(z, c);\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// InfBlocks\r\n\r\n\t// Table for deflate from PKZIP's appnote.txt.\r\n\tvar border = [ // Order of the bit length code lengths\r\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\r\n\r\n\tvar TYPE = 0; // get type bits (3, including end bit)\r\n\tvar LENS = 1; // get lengths for stored\r\n\tvar STORED = 2;// processing stored block\r\n\tvar TABLE = 3; // get table lengths\r\n\tvar BTREE = 4; // get bit lengths tree for a dynamic\r\n\t// block\r\n\tvar DTREE = 5; // get length, distance trees for a\r\n\t// dynamic block\r\n\tvar CODES = 6; // processing fixed or dynamic block\r\n\tvar DRY = 7; // output remaining window bytes\r\n\tvar DONELOCKS = 8; // finished last block, done\r\n\tvar BADBLOCKS = 9; // ot a data error--stuck here\r\n\r\n\tfunction InfBlocks(z, w) {\r\n\t\tvar that = this;\r\n\r\n\t\tvar mode = TYPE; // current inflate_block mode\r\n\r\n\t\tvar left = 0; // if STORED, bytes left to copy\r\n\r\n\t\tvar table = 0; // table lengths (14 bits)\r\n\t\tvar index = 0; // index into blens (or border)\r\n\t\tvar blens; // bit lengths of codes\r\n\t\tvar bb = [ 0 ]; // bit length tree depth\r\n\t\tvar tb = [ 0 ]; // bit length decoding tree\r\n\r\n\t\tvar codes = new InfCodes(); // if CODES, current state\r\n\r\n\t\tvar last = 0; // true if this block is the last block\r\n\r\n\t\tvar hufts = new Int32Array(MANY * 3); // single malloc for tree space\r\n\t\tvar check = 0; // check on output\r\n\t\tvar inftree = new InfTree();\r\n\r\n\t\tthat.bitk = 0; // bits in bit buffer\r\n\t\tthat.bitb = 0; // bit buffer\r\n\t\tthat.window = new Uint8Array(w); // sliding window\r\n\t\tthat.end = w; // one byte after sliding window\r\n\t\tthat.read = 0; // window read pointer\r\n\t\tthat.write = 0; // window write pointer\r\n\r\n\t\tthat.reset = function(z, c) {\r\n\t\t\tif (c)\r\n\t\t\t\tc[0] = check;\r\n\t\t\t// if (mode == BTREE || mode == DTREE) {\r\n\t\t\t// }\r\n\t\t\tif (mode == CODES) {\r\n\t\t\t\tcodes.free(z);\r\n\t\t\t}\r\n\t\t\tmode = TYPE;\r\n\t\t\tthat.bitk = 0;\r\n\t\t\tthat.bitb = 0;\r\n\t\t\tthat.read = that.write = 0;\r\n\t\t};\r\n\r\n\t\tthat.reset(z, null);\r\n\r\n\t\t// copy as much as possible from the sliding window to the output area\r\n\t\tthat.inflate_flush = function(z, r) {\r\n\t\t\tvar n;\r\n\t\t\tvar p;\r\n\t\t\tvar q;\r\n\r\n\t\t\t// local copies of source and destination pointers\r\n\t\t\tp = z.next_out_index;\r\n\t\t\tq = that.read;\r\n\r\n\t\t\t// compute number of bytes to copy as far as end of window\r\n\t\t\tn = /* (int) */((q <= that.write ? that.write : that.end) - q);\r\n\t\t\tif (n > z.avail_out)\r\n\t\t\t\tn = z.avail_out;\r\n\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\r\n\t\t\t\tr = Z_OK;\r\n\r\n\t\t\t// update counters\r\n\t\t\tz.avail_out -= n;\r\n\t\t\tz.total_out += n;\r\n\r\n\t\t\t// copy as far as end of window\r\n\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\r\n\t\t\tp += n;\r\n\t\t\tq += n;\r\n\r\n\t\t\t// see if more to copy at beginning of window\r\n\t\t\tif (q == that.end) {\r\n\t\t\t\t// wrap pointers\r\n\t\t\t\tq = 0;\r\n\t\t\t\tif (that.write == that.end)\r\n\t\t\t\t\tthat.write = 0;\r\n\r\n\t\t\t\t// compute bytes to copy\r\n\t\t\t\tn = that.write - q;\r\n\t\t\t\tif (n > z.avail_out)\r\n\t\t\t\t\tn = z.avail_out;\r\n\t\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\r\n\t\t\t\t\tr = Z_OK;\r\n\r\n\t\t\t\t// update counters\r\n\t\t\t\tz.avail_out -= n;\r\n\t\t\t\tz.total_out += n;\r\n\r\n\t\t\t\t// copy\r\n\t\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\r\n\t\t\t\tp += n;\r\n\t\t\t\tq += n;\r\n\t\t\t}\r\n\r\n\t\t\t// update pointers\r\n\t\t\tz.next_out_index = p;\r\n\t\t\tthat.read = q;\r\n\r\n\t\t\t// done\r\n\t\t\treturn r;\r\n\t\t};\r\n\r\n\t\tthat.proc = function(z, r) {\r\n\t\t\tvar t; // temporary storage\r\n\t\t\tvar b; // bit buffer\r\n\t\t\tvar k; // bits in bit buffer\r\n\t\t\tvar p; // input data pointer\r\n\t\t\tvar n; // bytes available there\r\n\t\t\tvar q; // output window write pointer\r\n\t\t\tvar m; // bytes to end of window or read pointer\r\n\r\n\t\t\tvar i;\r\n\r\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\r\n\t\t\t// {\r\n\t\t\tp = z.next_in_index;\r\n\t\t\tn = z.avail_in;\r\n\t\t\tb = that.bitb;\r\n\t\t\tk = that.bitk;\r\n\t\t\t// }\r\n\t\t\t// {\r\n\t\t\tq = that.write;\r\n\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t// }\r\n\r\n\t\t\t// process input based on current state\r\n\t\t\t// DEBUG dtree\r\n\t\t\twhile (true) {\r\n\t\t\t\tswitch (mode) {\r\n\t\t\t\tcase TYPE:\r\n\r\n\t\t\t\t\twhile (k < (3)) {\r\n\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tt = /* (int) */(b & 7);\r\n\t\t\t\t\tlast = t & 1;\r\n\r\n\t\t\t\t\tswitch (t >>> 1) {\r\n\t\t\t\t\tcase 0: // stored\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\tt = k & 7; // go to byte boundary\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (t);\r\n\t\t\t\t\t\tk -= (t);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\tmode = LENS; // get length of stored block\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 1: // fixed\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tvar bl = []; // new Array(1);\r\n\t\t\t\t\t\tvar bd = []; // new Array(1);\r\n\t\t\t\t\t\tvar tl = [ [] ]; // new Array(1);\r\n\t\t\t\t\t\tvar td = [ [] ]; // new Array(1);\r\n\r\n\t\t\t\t\t\tInfTree.inflate_trees_fixed(bl, bd, tl, td);\r\n\t\t\t\t\t\tcodes.init(bl[0], bd[0], tl[0], 0, td[0], 0);\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\tmode = CODES;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2: // dynamic\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\tmode = TABLE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3: // illegal\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\tz.msg = \"invalid block type\";\r\n\t\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase LENS:\r\n\r\n\t\t\t\t\twhile (k < (32)) {\r\n\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {\r\n\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\tz.msg = \"invalid stored block lengths\";\r\n\t\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tleft = (b & 0xffff);\r\n\t\t\t\t\tb = k = 0; // dump bits\r\n\t\t\t\t\tmode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase STORED:\r\n\t\t\t\t\tif (n === 0) {\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\r\n\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\tr = that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\tq = that.write;\r\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\r\n\t\t\t\t\t\t\t\tq = 0;\r\n\t\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (m === 0) {\r\n\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tr = Z_OK;\r\n\r\n\t\t\t\t\tt = left;\r\n\t\t\t\t\tif (t > n)\r\n\t\t\t\t\t\tt = n;\r\n\t\t\t\t\tif (t > m)\r\n\t\t\t\t\t\tt = m;\r\n\t\t\t\t\tthat.window.set(z.read_buf(p, t), q);\r\n\t\t\t\t\tp += t;\r\n\t\t\t\t\tn -= t;\r\n\t\t\t\t\tq += t;\r\n\t\t\t\t\tm -= t;\r\n\t\t\t\t\tif ((left -= t) !== 0)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tmode = last !== 0 ? DRY : TYPE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase TABLE:\r\n\r\n\t\t\t\t\twhile (k < (14)) {\r\n\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttable = t = (b & 0x3fff);\r\n\t\t\t\t\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\r\n\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\tz.msg = \"too many length or distance symbols\";\r\n\t\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\r\n\t\t\t\t\tif (!blens || blens.length < t) {\r\n\t\t\t\t\t\tblens = []; // new Array(t);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (i = 0; i < t; i++) {\r\n\t\t\t\t\t\t\tblens[i] = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// {\r\n\t\t\t\t\tb >>>= (14);\r\n\t\t\t\t\tk -= (14);\r\n\t\t\t\t\t// }\r\n\r\n\t\t\t\t\tindex = 0;\r\n\t\t\t\t\tmode = BTREE;\r\n\t\t\t\tcase BTREE:\r\n\t\t\t\t\twhile (index < 4 + (table >>> 10)) {\r\n\t\t\t\t\t\twhile (k < (3)) {\r\n\t\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tblens[border[index++]] = b & 7;\r\n\r\n\t\t\t\t\t\t// {\r\n\t\t\t\t\t\tb >>>= (3);\r\n\t\t\t\t\t\tk -= (3);\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile (index < 19) {\r\n\t\t\t\t\t\tblens[border[index++]] = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbb[0] = 7;\r\n\t\t\t\t\tt = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\r\n\t\t\t\t\tif (t != Z_OK) {\r\n\t\t\t\t\t\tr = t;\r\n\t\t\t\t\t\tif (r == Z_DATA_ERROR) {\r\n\t\t\t\t\t\t\tblens = null;\r\n\t\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tindex = 0;\r\n\t\t\t\t\tmode = DTREE;\r\n\t\t\t\tcase DTREE:\r\n\t\t\t\t\twhile (true) {\r\n\t\t\t\t\t\tt = table;\r\n\t\t\t\t\t\tif (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar j, c;\r\n\r\n\t\t\t\t\t\tt = bb[0];\r\n\r\n\t\t\t\t\t\twhile (k < (t)) {\r\n\t\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if (tb[0] == -1) {\r\n\t\t\t\t\t\t// System.err.println(\"null...\");\r\n\t\t\t\t\t\t// }\r\n\r\n\t\t\t\t\t\tt = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\r\n\t\t\t\t\t\tc = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\r\n\r\n\t\t\t\t\t\tif (c < 16) {\r\n\t\t\t\t\t\t\tb >>>= (t);\r\n\t\t\t\t\t\t\tk -= (t);\r\n\t\t\t\t\t\t\tblens[index++] = c;\r\n\t\t\t\t\t\t} else { // c == 16..18\r\n\t\t\t\t\t\t\ti = c == 18 ? 7 : c - 14;\r\n\t\t\t\t\t\t\tj = c == 18 ? 11 : 3;\r\n\r\n\t\t\t\t\t\t\twhile (k < (t + i)) {\r\n\t\t\t\t\t\t\t\tif (n !== 0) {\r\n\t\t\t\t\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tn--;\r\n\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\r\n\t\t\t\t\t\t\t\tk += 8;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tb >>>= (t);\r\n\t\t\t\t\t\t\tk -= (t);\r\n\r\n\t\t\t\t\t\t\tj += (b & inflate_mask[i]);\r\n\r\n\t\t\t\t\t\t\tb >>>= (i);\r\n\t\t\t\t\t\t\tk -= (i);\r\n\r\n\t\t\t\t\t\t\ti = index;\r\n\t\t\t\t\t\t\tt = table;\r\n\t\t\t\t\t\t\tif (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {\r\n\t\t\t\t\t\t\t\tblens = null;\r\n\t\t\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\t\t\tz.msg = \"invalid bit length repeat\";\r\n\t\t\t\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tc = c == 16 ? blens[i - 1] : 0;\r\n\t\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\t\tblens[i++] = c;\r\n\t\t\t\t\t\t\t} while (--j !== 0);\r\n\t\t\t\t\t\t\tindex = i;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttb[0] = -1;\r\n\t\t\t\t\t// {\r\n\t\t\t\t\tvar bl_ = []; // new Array(1);\r\n\t\t\t\t\tvar bd_ = []; // new Array(1);\r\n\t\t\t\t\tvar tl_ = []; // new Array(1);\r\n\t\t\t\t\tvar td_ = []; // new Array(1);\r\n\t\t\t\t\tbl_[0] = 9; // must be <= 9 for lookahead assumptions\r\n\t\t\t\t\tbd_[0] = 6; // must be <= 9 for lookahead assumptions\r\n\r\n\t\t\t\t\tt = table;\r\n\t\t\t\t\tt = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\r\n\r\n\t\t\t\t\tif (t != Z_OK) {\r\n\t\t\t\t\t\tif (t == Z_DATA_ERROR) {\r\n\t\t\t\t\t\t\tblens = null;\r\n\t\t\t\t\t\t\tmode = BADBLOCKS;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tr = t;\r\n\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcodes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);\r\n\t\t\t\t\t// }\r\n\t\t\t\t\tmode = CODES;\r\n\t\t\t\tcase CODES:\r\n\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\tthat.write = q;\r\n\r\n\t\t\t\t\tif ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tr = Z_OK;\r\n\t\t\t\t\tcodes.free(z);\r\n\r\n\t\t\t\t\tp = z.next_in_index;\r\n\t\t\t\t\tn = z.avail_in;\r\n\t\t\t\t\tb = that.bitb;\r\n\t\t\t\t\tk = that.bitk;\r\n\t\t\t\t\tq = that.write;\r\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\r\n\t\t\t\t\tif (last === 0) {\r\n\t\t\t\t\t\tmode = TYPE;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = DRY;\r\n\t\t\t\tcase DRY:\r\n\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\tr = that.inflate_flush(z, r);\r\n\t\t\t\t\tq = that.write;\r\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\r\n\t\t\t\t\tif (that.read != that.write) {\r\n\t\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmode = DONELOCKS;\r\n\t\t\t\tcase DONELOCKS:\r\n\t\t\t\t\tr = Z_STREAM_END;\r\n\r\n\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\tcase BADBLOCKS:\r\n\t\t\t\t\tr = Z_DATA_ERROR;\r\n\r\n\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tr = Z_STREAM_ERROR;\r\n\r\n\t\t\t\t\tthat.bitb = b;\r\n\t\t\t\t\tthat.bitk = k;\r\n\t\t\t\t\tz.avail_in = n;\r\n\t\t\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\t\t\tz.next_in_index = p;\r\n\t\t\t\t\tthat.write = q;\r\n\t\t\t\t\treturn that.inflate_flush(z, r);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthat.free = function(z) {\r\n\t\t\tthat.reset(z, null);\r\n\t\t\tthat.window = null;\r\n\t\t\thufts = null;\r\n\t\t\t// ZFREE(z, s);\r\n\t\t};\r\n\r\n\t\tthat.set_dictionary = function(d, start, n) {\r\n\t\t\tthat.window.set(d.subarray(start, start + n), 0);\r\n\t\t\tthat.read = that.write = n;\r\n\t\t};\r\n\r\n\t\t// Returns true if inflate is currently at the end of a block generated\r\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH.\r\n\t\tthat.sync_point = function() {\r\n\t\t\treturn mode == LENS ? 1 : 0;\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// Inflate\r\n\r\n\t// preset dictionary flag in zlib header\r\n\tvar PRESET_DICT = 0x20;\r\n\r\n\tvar Z_DEFLATED = 8;\r\n\r\n\tvar METHOD = 0; // waiting for method byte\r\n\tvar FLAG = 1; // waiting for flag byte\r\n\tvar DICT4 = 2; // four dictionary check bytes to go\r\n\tvar DICT3 = 3; // three dictionary check bytes to go\r\n\tvar DICT2 = 4; // two dictionary check bytes to go\r\n\tvar DICT1 = 5; // one dictionary check byte to go\r\n\tvar DICT0 = 6; // waiting for inflateSetDictionary\r\n\tvar BLOCKS = 7; // decompressing blocks\r\n\tvar DONE = 12; // finished check, done\r\n\tvar BAD = 13; // got an error--stay here\r\n\r\n\tvar mark = [ 0, 0, 0xff, 0xff ];\r\n\r\n\tfunction Inflate() {\r\n\t\tvar that = this;\r\n\r\n\t\tthat.mode = 0; // current inflate mode\r\n\r\n\t\t// mode dependent information\r\n\t\tthat.method = 0; // if FLAGS, method byte\r\n\r\n\t\t// if CHECK, check values to compare\r\n\t\tthat.was = [ 0 ]; // new Array(1); // computed check value\r\n\t\tthat.need = 0; // stream check value\r\n\r\n\t\t// if BAD, inflateSync's marker bytes count\r\n\t\tthat.marker = 0;\r\n\r\n\t\t// mode independent information\r\n\t\tthat.wbits = 0; // log2(window size) (8..15, defaults to 15)\r\n\r\n\t\t// this.blocks; // current inflate_blocks state\r\n\r\n\t\tfunction inflateReset(z) {\r\n\t\t\tif (!z || !z.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\r\n\t\t\tz.total_in = z.total_out = 0;\r\n\t\t\tz.msg = null;\r\n\t\t\tz.istate.mode = BLOCKS;\r\n\t\t\tz.istate.blocks.reset(z, null);\r\n\t\t\treturn Z_OK;\r\n\t\t}\r\n\r\n\t\tthat.inflateEnd = function(z) {\r\n\t\t\tif (that.blocks)\r\n\t\t\t\tthat.blocks.free(z);\r\n\t\t\tthat.blocks = null;\r\n\t\t\t// ZFREE(z, z->state);\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t\tthat.inflateInit = function(z, w) {\r\n\t\t\tz.msg = null;\r\n\t\t\tthat.blocks = null;\r\n\r\n\t\t\t// set window size\r\n\t\t\tif (w < 8 || w > 15) {\r\n\t\t\t\tthat.inflateEnd(z);\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\t}\r\n\t\t\tthat.wbits = w;\r\n\r\n\t\t\tz.istate.blocks = new InfBlocks(z, 1 << w);\r\n\r\n\t\t\t// reset state\r\n\t\t\tinflateReset(z);\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t\tthat.inflate = function(z, f) {\r\n\t\t\tvar r;\r\n\t\t\tvar b;\r\n\r\n\t\t\tif (!z || !z.istate || !z.next_in)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\tf = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\r\n\t\t\tr = Z_BUF_ERROR;\r\n\t\t\twhile (true) {\r\n\t\t\t\t// System.out.println(\"mode: \"+z.istate.mode);\r\n\t\t\t\tswitch (z.istate.mode) {\r\n\t\t\t\tcase METHOD:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tif (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\r\n\t\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\t\tz.msg = \"unknown compression method\";\r\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((z.istate.method >> 4) + 8 > z.istate.wbits) {\r\n\t\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\t\tz.msg = \"invalid window size\";\r\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tz.istate.mode = FLAG;\r\n\t\t\t\tcase FLAG:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tb = (z.read_byte(z.next_in_index++)) & 0xff;\r\n\r\n\t\t\t\t\tif ((((z.istate.method << 8) + b) % 31) !== 0) {\r\n\t\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\t\tz.msg = \"incorrect header check\";\r\n\t\t\t\t\t\tz.istate.marker = 5; // can't try inflateSync\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ((b & PRESET_DICT) === 0) {\r\n\t\t\t\t\t\tz.istate.mode = BLOCKS;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tz.istate.mode = DICT4;\r\n\t\t\t\tcase DICT4:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tz.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;\r\n\t\t\t\t\tz.istate.mode = DICT3;\r\n\t\t\t\tcase DICT3:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;\r\n\t\t\t\t\tz.istate.mode = DICT2;\r\n\t\t\t\tcase DICT2:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;\r\n\t\t\t\t\tz.istate.mode = DICT1;\r\n\t\t\t\tcase DICT1:\r\n\r\n\t\t\t\t\tif (z.avail_in === 0)\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\tr = f;\r\n\r\n\t\t\t\t\tz.avail_in--;\r\n\t\t\t\t\tz.total_in++;\r\n\t\t\t\t\tz.istate.need += (z.read_byte(z.next_in_index++) & 0xff);\r\n\t\t\t\t\tz.istate.mode = DICT0;\r\n\t\t\t\t\treturn Z_NEED_DICT;\r\n\t\t\t\tcase DICT0:\r\n\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\tz.msg = \"need dictionary\";\r\n\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\r\n\t\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\t\tcase BLOCKS:\r\n\r\n\t\t\t\t\tr = z.istate.blocks.proc(z, r);\r\n\t\t\t\t\tif (r == Z_DATA_ERROR) {\r\n\t\t\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (r == Z_OK) {\r\n\t\t\t\t\t\tr = f;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (r != Z_STREAM_END) {\r\n\t\t\t\t\t\treturn r;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tr = f;\r\n\t\t\t\t\tz.istate.blocks.reset(z, z.istate.was);\r\n\t\t\t\t\tz.istate.mode = DONE;\r\n\t\t\t\tcase DONE:\r\n\t\t\t\t\treturn Z_STREAM_END;\r\n\t\t\t\tcase BAD:\r\n\t\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthat.inflateSetDictionary = function(z, dictionary, dictLength) {\r\n\t\t\tvar index = 0;\r\n\t\t\tvar length = dictLength;\r\n\t\t\tif (!z || !z.istate || z.istate.mode != DICT0)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\r\n\t\t\tif (length >= (1 << z.istate.wbits)) {\r\n\t\t\t\tlength = (1 << z.istate.wbits) - 1;\r\n\t\t\t\tindex = dictLength - length;\r\n\t\t\t}\r\n\t\t\tz.istate.blocks.set_dictionary(dictionary, index, length);\r\n\t\t\tz.istate.mode = BLOCKS;\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t\tthat.inflateSync = function(z) {\r\n\t\t\tvar n; // number of bytes to look at\r\n\t\t\tvar p; // pointer to bytes\r\n\t\t\tvar m; // number of marker bytes found in a row\r\n\t\t\tvar r, w; // temporaries to save total_in and total_out\r\n\r\n\t\t\t// set up\r\n\t\t\tif (!z || !z.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\tif (z.istate.mode != BAD) {\r\n\t\t\t\tz.istate.mode = BAD;\r\n\t\t\t\tz.istate.marker = 0;\r\n\t\t\t}\r\n\t\t\tif ((n = z.avail_in) === 0)\r\n\t\t\t\treturn Z_BUF_ERROR;\r\n\t\t\tp = z.next_in_index;\r\n\t\t\tm = z.istate.marker;\r\n\r\n\t\t\t// search\r\n\t\t\twhile (n !== 0 && m < 4) {\r\n\t\t\t\tif (z.read_byte(p) == mark[m]) {\r\n\t\t\t\t\tm++;\r\n\t\t\t\t} else if (z.read_byte(p) !== 0) {\r\n\t\t\t\t\tm = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tm = 4 - m;\r\n\t\t\t\t}\r\n\t\t\t\tp++;\r\n\t\t\t\tn--;\r\n\t\t\t}\r\n\r\n\t\t\t// restore\r\n\t\t\tz.total_in += p - z.next_in_index;\r\n\t\t\tz.next_in_index = p;\r\n\t\t\tz.avail_in = n;\r\n\t\t\tz.istate.marker = m;\r\n\r\n\t\t\t// return no joy or set up to restart on a new block\r\n\t\t\tif (m != 4) {\r\n\t\t\t\treturn Z_DATA_ERROR;\r\n\t\t\t}\r\n\t\t\tr = z.total_in;\r\n\t\t\tw = z.total_out;\r\n\t\t\tinflateReset(z);\r\n\t\t\tz.total_in = r;\r\n\t\t\tz.total_out = w;\r\n\t\t\tz.istate.mode = BLOCKS;\r\n\t\t\treturn Z_OK;\r\n\t\t};\r\n\r\n\t\t// Returns true if inflate is currently at the end of a block generated\r\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\r\n\t\t// implementation to provide an additional safety check. PPP uses\r\n\t\t// Z_SYNC_FLUSH\r\n\t\t// but removes the length bytes of the resulting empty stored block. When\r\n\t\t// decompressing, PPP checks that at the end of input packet, inflate is\r\n\t\t// waiting for these length bytes.\r\n\t\tthat.inflateSyncPoint = function(z) {\r\n\t\t\tif (!z || !z.istate || !z.istate.blocks)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\treturn z.istate.blocks.sync_point();\r\n\t\t};\r\n\t}\r\n\r\n\t// ZStream\r\n\r\n\tfunction ZStream() {\r\n\t}\r\n\r\n\tZStream.prototype = {\r\n\t\tinflateInit : function(bits) {\r\n\t\t\tvar that = this;\r\n\t\t\tthat.istate = new Inflate();\r\n\t\t\tif (!bits)\r\n\t\t\t\tbits = MAX_BITS;\r\n\t\t\treturn that.istate.inflateInit(that, bits);\r\n\t\t},\r\n\r\n\t\tinflate : function(f) {\r\n\t\t\tvar that = this;\r\n\t\t\tif (!that.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\treturn that.istate.inflate(that, f);\r\n\t\t},\r\n\r\n\t\tinflateEnd : function() {\r\n\t\t\tvar that = this;\r\n\t\t\tif (!that.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\tvar ret = that.istate.inflateEnd(that);\r\n\t\t\tthat.istate = null;\r\n\t\t\treturn ret;\r\n\t\t},\r\n\r\n\t\tinflateSync : function() {\r\n\t\t\tvar that = this;\r\n\t\t\tif (!that.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\treturn that.istate.inflateSync(that);\r\n\t\t},\r\n\t\tinflateSetDictionary : function(dictionary, dictLength) {\r\n\t\t\tvar that = this;\r\n\t\t\tif (!that.istate)\r\n\t\t\t\treturn Z_STREAM_ERROR;\r\n\t\t\treturn that.istate.inflateSetDictionary(that, dictionary, dictLength);\r\n\t\t},\r\n\t\tread_byte : function(start) {\r\n\t\t\tvar that = this;\r\n\t\t\treturn that.next_in.subarray(start, start + 1)[0];\r\n\t\t},\r\n\t\tread_buf : function(start, size) {\r\n\t\t\tvar that = this;\r\n\t\t\treturn that.next_in.subarray(start, start + size);\r\n\t\t}\r\n\t};\r\n\r\n\t// Inflater\r\n\r\n\tfunction Inflater() {\r\n\t\tvar that = this;\r\n\t\tvar z = new ZStream();\r\n\t\tvar bufsize = 512;\r\n\t\tvar flush = Z_NO_FLUSH;\r\n\t\tvar buf = new Uint8Array(bufsize);\r\n\t\tvar nomoreinput = false;\r\n\r\n\t\tz.inflateInit();\r\n\t\tz.next_out = buf;\r\n\r\n\t\tthat.append = function(data, onprogress) {\r\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\r\n\t\t\tif (data.length === 0)\r\n\t\t\t\treturn;\r\n\t\t\tz.next_in_index = 0;\r\n\t\t\tz.next_in = data;\r\n\t\t\tz.avail_in = data.length;\r\n\t\t\tdo {\r\n\t\t\t\tz.next_out_index = 0;\r\n\t\t\t\tz.avail_out = bufsize;\r\n\t\t\t\tif ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it\r\n\t\t\t\t\tz.next_in_index = 0;\r\n\t\t\t\t\tnomoreinput = true;\r\n\t\t\t\t}\r\n\t\t\t\terr = z.inflate(flush);\r\n\t\t\t\tif (nomoreinput && (err == Z_BUF_ERROR))\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif (err != Z_OK && err != Z_STREAM_END)\r\n\t\t\t\t\tthrow \"inflating: \" + z.msg;\r\n\t\t\t\tif ((nomoreinput || err == Z_STREAM_END) && (z.avail_in == data.length))\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\tif (z.next_out_index)\r\n\t\t\t\t\tif (z.next_out_index == bufsize)\r\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\r\n\t\t\t\tbufferSize += z.next_out_index;\r\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\r\n\t\t\t\t\tonprogress(z.next_in_index);\r\n\t\t\t\t\tlastIndex = z.next_in_index;\r\n\t\t\t\t}\r\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\r\n\t\t\tarray = new Uint8Array(bufferSize);\r\n\t\t\tbuffers.forEach(function(chunk) {\r\n\t\t\t\tarray.set(chunk, bufferIndex);\r\n\t\t\t\tbufferIndex += chunk.length;\r\n\t\t\t});\r\n\t\t\treturn array;\r\n\t\t};\r\n\t\tthat.flush = function() {\r\n\t\t\tz.inflateEnd();\r\n\t\t};\r\n\t}\r\n\r\n\tvar inflater;\r\n\r\n\tif (obj.zip)\r\n\t\tobj.zip.Inflater = Inflater;\r\n\telse {\r\n\t\tinflater = new Inflater();\r\n\t\tobj.addEventListener(\"message\", function(event) {\r\n\t\t\tvar message = event.data;\r\n\r\n\t\t\tif (message.append)\r\n\t\t\t\tobj.postMessage({\r\n\t\t\t\t\tonappend : true,\r\n\t\t\t\t\tdata : inflater.append(message.data, function(current) {\r\n\t\t\t\t\t\tobj.postMessage({\r\n\t\t\t\t\t\t\tprogress : true,\r\n\t\t\t\t\t\t\tcurrent : current\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t})\r\n\t\t\t\t});\r\n\t\t\tif (message.flush) {\r\n\t\t\t\tinflater.flush();\r\n\t\t\t\tobj.postMessage({\r\n\t\t\t\t\tonflush : true\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}, false);\r\n\t}\r\n\r\n})(self);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/string-replace-webpack-plugin/loader.js?id=0v4ss6yfw2!./node_modules/string-replace-webpack-plugin/loader.js?id=bvkgejv645k!./node_modules/terriajs/buildprocess/removeCesiumDebugPragmas.js!./node_modules/terriajs-cesium/Source/ThirdParty/Workers/inflate.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}